<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.0 Transitional//EN" "http://www.w3.org/TR/REC-html40/loose.dtd">
<html>

<head>

<META NAME="GENERATOR" CONTENT="pythondoc 0.7 (Sat Feb 01 16:31:54 2003)">

<link rel="stylesheet" href="pythondoc.css" type="text/css">

<title>Class GenEdit</title>
</head>

<body>
<P><A HREF="index.html">Table of contents</A> <A HREF="indices.html">Index</A></P>


<H1 CLASS="ClassName">class GenEdit</H1>
<P CLASS="DeclaredIn">Declared in module <A HREF="GenEdit.html">GenEdit</A></P>

<H2 CLASS="ClassHierarchy">Inheritance hierarchy:</H2><P CLASS="ClassHierarchy">GenEdit.GenEdit<BR>
&nbsp;&nbsp;Object.OwnerObject<BR>
</P>

<H2>Synopsis</H2>
<PRE CLASS="ClassDeclaration">
<SPAN CLASS="PyKeyword">class</SPAN> <SPAN CLASS="ClassName">GenEdit</SPAN>(<A CLASS="DocLink" HREF="Object.OwnerObject.html">OwnerObject</A>):
    <A CLASS="DocLink" HREF="#GenEdit.GenEdit.__init__"><SPAN CLASS="PyKeyword">def</SPAN> <SPAN CLASS="FunctionName">GenEdit.GenEdit.__init__</SPAN></A>(<SPAN CLASS="Argument">self</SPAN>, <SPAN CLASS="Argument">**args</SPAN>)
    <A CLASS="DocLink" HREF="#GenEdit.GenEdit.active_frame"><SPAN CLASS="PyKeyword">def</SPAN> <SPAN CLASS="FunctionName">GenEdit.GenEdit.active_frame</SPAN></A>(<SPAN CLASS="Argument">self</SPAN>)<SPAN CLASS="OneLiner"> # returns the currently active frame, if any</SPAN>
    <A CLASS="DocLink" HREF="#GenEdit.GenEdit.app_active_buffer_name"><SPAN CLASS="PyKeyword">def</SPAN> <SPAN CLASS="FunctionName">GenEdit.GenEdit.app_active_buffer_name</SPAN></A>(<SPAN CLASS="Argument">self</SPAN>)
    <A CLASS="DocLink" HREF="#GenEdit.GenEdit.app_change_buffer"><SPAN CLASS="PyKeyword">def</SPAN> <SPAN CLASS="FunctionName">GenEdit.GenEdit.app_change_buffer</SPAN></A>(<SPAN CLASS="Argument">self</SPAN>, <SPAN CLASS="Argument">buff_name</SPAN>)<SPAN CLASS="OneLiner"> # Changes the external application's active buffer.</SPAN>
    <A CLASS="DocLink" HREF="#GenEdit.GenEdit.app_close_buffer"><SPAN CLASS="PyKeyword">def</SPAN> <SPAN CLASS="FunctionName">GenEdit.GenEdit.app_close_buffer</SPAN></A>(<SPAN CLASS="Argument">self</SPAN>, <SPAN CLASS="Argument">buff_name</SPAN>, <SPAN CLASS="Argument">save=0</SPAN>)<SPAN CLASS="OneLiner"> # Close a buffer.</SPAN>
    <A CLASS="DocLink" HREF="#GenEdit.GenEdit.editor_buffer"><SPAN CLASS="PyKeyword">def</SPAN> <SPAN CLASS="FunctionName">GenEdit.GenEdit.editor_buffer</SPAN></A>(<SPAN CLASS="Argument">self</SPAN>, <SPAN CLASS="Argument">buff_name</SPAN>)
    <A CLASS="DocLink" HREF="#GenEdit.GenEdit.editor_has_focus"><SPAN CLASS="PyKeyword">def</SPAN> <SPAN CLASS="FunctionName">GenEdit.GenEdit.editor_has_focus</SPAN></A>(<SPAN CLASS="Argument">self</SPAN>)<SPAN CLASS="OneLiner"> # indicates whether the editor window has the focus</SPAN>
    <A CLASS="DocLink" HREF="#GenEdit.GenEdit.file_name"><SPAN CLASS="PyKeyword">def</SPAN> <SPAN CLASS="FunctionName">GenEdit.GenEdit.file_name</SPAN></A>(<SPAN CLASS="Argument">self</SPAN>, <SPAN CLASS="Argument">buff_name</SPAN>)<SPAN CLASS="OneLiner"> # returns the current filename associated with a given buffer</SPAN>
    <A CLASS="DocLink" HREF="#GenEdit.GenEdit.is_active"><SPAN CLASS="PyKeyword">def</SPAN> <SPAN CLASS="FunctionName">GenEdit.GenEdit.is_active</SPAN></A>(<SPAN CLASS="Argument">self</SPAN>)<SPAN CLASS="OneLiner"> # indicates whether an editor frame is active</SPAN>
    <A CLASS="DocLink" HREF="#GenEdit.GenEdit.mic_change"><SPAN CLASS="PyKeyword">def</SPAN> <SPAN CLASS="FunctionName">GenEdit.GenEdit.mic_change</SPAN></A>(<SPAN CLASS="Argument">self</SPAN>, <SPAN CLASS="Argument">state</SPAN>)<SPAN CLASS="OneLiner"> # function to receive microphone state change callbacks</SPAN>
    <A CLASS="DocLink" HREF="#GenEdit.GenEdit.multiple_buffers"><SPAN CLASS="PyKeyword">def</SPAN> <SPAN CLASS="FunctionName">GenEdit.GenEdit.multiple_buffers</SPAN></A>(<SPAN CLASS="Argument">self</SPAN>)<SPAN CLASS="OneLiner"> # does editor support multiple open buffers?</SPAN>
    <A CLASS="DocLink" HREF="#GenEdit.GenEdit.multiple_windows"><SPAN CLASS="PyKeyword">def</SPAN> <SPAN CLASS="FunctionName">GenEdit.GenEdit.multiple_windows</SPAN></A>(<SPAN CLASS="Argument">self</SPAN>)<SPAN CLASS="OneLiner"> # does editor support multiple windows per instance?</SPAN>
    <A CLASS="DocLink" HREF="#GenEdit.GenEdit.new_buffer"><SPAN CLASS="PyKeyword">def</SPAN> <SPAN CLASS="FunctionName">GenEdit.GenEdit.new_buffer</SPAN></A>(<SPAN CLASS="Argument">self</SPAN>, <SPAN CLASS="Argument">buff_name</SPAN>, <SPAN CLASS="Argument">buffer</SPAN>, <SPAN CLASS="Argument">perform_callback=1</SPAN>)
    <A CLASS="DocLink" HREF="#GenEdit.GenEdit.on_exit"><SPAN CLASS="PyKeyword">def</SPAN> <SPAN CLASS="FunctionName">GenEdit.GenEdit.on_exit</SPAN></A>(<SPAN CLASS="Argument">self</SPAN>, <SPAN CLASS="Argument">ID=None</SPAN>)
    <A CLASS="DocLink" HREF="#GenEdit.GenEdit.open_buffers"><SPAN CLASS="PyKeyword">def</SPAN> <SPAN CLASS="FunctionName">GenEdit.GenEdit.open_buffers</SPAN></A>(<SPAN CLASS="Argument">self</SPAN>)
    <A CLASS="DocLink" HREF="#GenEdit.GenEdit.open_file"><SPAN CLASS="PyKeyword">def</SPAN> <SPAN CLASS="FunctionName">GenEdit.GenEdit.open_file</SPAN></A>(<SPAN CLASS="Argument">self</SPAN>, <SPAN CLASS="Argument">file_name</SPAN>, <SPAN CLASS="Argument">perform_callback=0</SPAN>)<SPAN CLASS="OneLiner"> # opens a new file </SPAN>
    <A CLASS="DocLink" HREF="#GenEdit.GenEdit.open_file_dialog"><SPAN CLASS="PyKeyword">def</SPAN> <SPAN CLASS="FunctionName">GenEdit.GenEdit.open_file_dialog</SPAN></A>(<SPAN CLASS="Argument">self</SPAN>)<SPAN CLASS="OneLiner"> # prompts for a file to open</SPAN>
    <A CLASS="DocLink" HREF="#GenEdit.GenEdit.overwrite_prompt"><SPAN CLASS="PyKeyword">def</SPAN> <SPAN CLASS="FunctionName">GenEdit.GenEdit.overwrite_prompt</SPAN></A>(<SPAN CLASS="Argument">self</SPAN>, <SPAN CLASS="Argument">buff_name</SPAN>, <SPAN CLASS="Argument">full_path</SPAN>)
    <A CLASS="DocLink" HREF="#GenEdit.GenEdit.prompt_to_save"><SPAN CLASS="PyKeyword">def</SPAN> <SPAN CLASS="FunctionName">GenEdit.GenEdit.prompt_to_save</SPAN></A>(<SPAN CLASS="Argument">self</SPAN>, <SPAN CLASS="Argument">buff_name</SPAN>)
    <A CLASS="DocLink" HREF="#GenEdit.GenEdit.rename_buffer"><SPAN CLASS="PyKeyword">def</SPAN> <SPAN CLASS="FunctionName">GenEdit.GenEdit.rename_buffer</SPAN></A>(<SPAN CLASS="Argument">self</SPAN>, <SPAN CLASS="Argument">buff_name</SPAN>, <SPAN CLASS="Argument">new_buff_name</SPAN>, <SPAN CLASS="Argument">perform_callback=1</SPAN>)
    <A CLASS="DocLink" HREF="#GenEdit.GenEdit.save_as_dialog"><SPAN CLASS="PyKeyword">def</SPAN> <SPAN CLASS="FunctionName">GenEdit.GenEdit.save_as_dialog</SPAN></A>(<SPAN CLASS="Argument">self</SPAN>, <SPAN CLASS="Argument">buff_name</SPAN>)
    <A CLASS="DocLink" HREF="#GenEdit.GenEdit.save_file"><SPAN CLASS="PyKeyword">def</SPAN> <SPAN CLASS="FunctionName">GenEdit.GenEdit.save_file</SPAN></A>(<SPAN CLASS="Argument">self</SPAN>, <SPAN CLASS="Argument">buff_name</SPAN>, <SPAN CLASS="Argument">full_path=None</SPAN>, <SPAN CLASS="Argument">no_prompt=0</SPAN>, <SPAN CLASS="Argument">rename_buff=1</SPAN>, <SPAN CLASS="Argument">ask_for_new_name=0</SPAN>, <SPAN CLASS="Argument">perform_callback=0</SPAN>)<SPAN CLASS="OneLiner"> # Saves the buffer buff_name to a file</SPAN>
    <A CLASS="DocLink" HREF="#GenEdit.GenEdit.set_app_control"><SPAN CLASS="PyKeyword">def</SPAN> <SPAN CLASS="FunctionName">GenEdit.GenEdit.set_app_control</SPAN></A>(<SPAN CLASS="Argument">self</SPAN>, <SPAN CLASS="Argument">app_control</SPAN>)
    <A CLASS="DocLink" HREF="#GenEdit.GenEdit.set_instance_string"><SPAN CLASS="PyKeyword">def</SPAN> <SPAN CLASS="FunctionName">GenEdit.GenEdit.set_instance_string</SPAN></A>(<SPAN CLASS="Argument">self</SPAN>, <SPAN CLASS="Argument">instance_string</SPAN>)

    <SPAN CLASS="InheritsHead"># Inherited from Object.Object</SPAN>
    <SPAN CLASS="PyKeyword">def</SPAN> <SPAN CLASS="FunctionName">Object.Object.__init__</SPAN>(<SPAN CLASS="Argument">self</SPAN>, <SPAN CLASS="Argument">**args_super</SPAN>)
    <A CLASS="DocLink" HREF="#Object.Object.decl_attrs"><SPAN CLASS="PyKeyword">def</SPAN> <SPAN CLASS="FunctionName">Object.Object.decl_attrs</SPAN></A>(<SPAN CLASS="Argument">self</SPAN>, <SPAN CLASS="Argument">attrs</SPAN>)<SPAN CLASS="OneLiner"> # Define new attributes for <EM>self</EM></SPAN>
    <A CLASS="DocLink" HREF="#Object.Object.deep_construct"><SPAN CLASS="PyKeyword">def</SPAN> <SPAN CLASS="FunctionName">Object.Object.deep_construct</SPAN></A>(<SPAN CLASS="Argument">self</SPAN>, <SPAN CLASS="Argument">this_class</SPAN>, <SPAN CLASS="Argument">attrs_this_class</SPAN>, <SPAN CLASS="Argument">args_super</SPAN>, <SPAN CLASS="Argument">new_default={}</SPAN>, <SPAN CLASS="Argument">enforce_value={}</SPAN>, <SPAN CLASS="Argument">exclude_bases={}</SPAN>)<SPAN CLASS="OneLiner"> # Build an instance of a class.</SPAN>
    <A CLASS="DocLink" HREF="#Object.Object.init_attrs"><SPAN CLASS="PyKeyword">def</SPAN> <SPAN CLASS="FunctionName">Object.Object.init_attrs</SPAN></A>(<SPAN CLASS="Argument">self</SPAN>, <SPAN CLASS="Argument">attrs</SPAN>)<SPAN CLASS="OneLiner"> # Initialises existing attributes</SPAN>
    <A CLASS="DocLink" HREF="#Object.Object.possibly_init_attrs"><SPAN CLASS="PyKeyword">def</SPAN> <SPAN CLASS="FunctionName">Object.Object.possibly_init_attrs</SPAN></A>(<SPAN CLASS="Argument">self</SPAN>, <SPAN CLASS="Argument">attrs</SPAN>)

    <SPAN CLASS="InheritsHead"># Inherited from Object.OwnerObject</SPAN>
    <SPAN CLASS="PyKeyword">def</SPAN> <SPAN CLASS="FunctionName">Object.OwnerObject.__init__</SPAN>(<SPAN CLASS="Argument">self</SPAN>, <SPAN CLASS="Argument">**attrs</SPAN>)
    <A CLASS="DocLink" HREF="#Object.OwnerObject._cleanup_object"><SPAN CLASS="PyKeyword">def</SPAN> <SPAN CLASS="FunctionName">Object.OwnerObject._cleanup_object</SPAN></A>(<SPAN CLASS="Argument">self</SPAN>, <SPAN CLASS="Argument">object</SPAN>)<SPAN CLASS="OneLiner"> # attempt to call cleanup on object</SPAN>
    <A CLASS="DocLink" HREF="#Object.OwnerObject.add_grandparent"><SPAN CLASS="PyKeyword">def</SPAN> <SPAN CLASS="FunctionName">Object.OwnerObject.add_grandparent</SPAN></A>(<SPAN CLASS="Argument">self</SPAN>, <SPAN CLASS="Argument">grandparent</SPAN>)
    <A CLASS="DocLink" HREF="#Object.OwnerObject.add_owned"><SPAN CLASS="PyKeyword">def</SPAN> <SPAN CLASS="FunctionName">Object.OwnerObject.add_owned</SPAN></A>(<SPAN CLASS="Argument">self</SPAN>, <SPAN CLASS="Argument">owned</SPAN>)<SPAN CLASS="OneLiner"> # append a new attribute name to the list of owned objects</SPAN>
    <A CLASS="DocLink" HREF="#Object.OwnerObject.add_owned_list"><SPAN CLASS="PyKeyword">def</SPAN> <SPAN CLASS="FunctionName">Object.OwnerObject.add_owned_list</SPAN></A>(<SPAN CLASS="Argument">self</SPAN>, <SPAN CLASS="Argument">owned</SPAN>)<SPAN CLASS="OneLiner"> # append new attribute names to the list of owned objects</SPAN>
    <A CLASS="DocLink" HREF="#Object.OwnerObject.cleanup"><SPAN CLASS="PyKeyword">def</SPAN> <SPAN CLASS="FunctionName">Object.OwnerObject.cleanup</SPAN></A>(<SPAN CLASS="Argument">self</SPAN>)
    <A CLASS="DocLink" HREF="#Object.OwnerObject.name_parent"><SPAN CLASS="PyKeyword">def</SPAN> <SPAN CLASS="FunctionName">Object.OwnerObject.name_parent</SPAN></A>(<SPAN CLASS="Argument">self</SPAN>, <SPAN CLASS="Argument">parent=None</SPAN>)
    <A CLASS="DocLink" HREF="#Object.OwnerObject.owned_by"><SPAN CLASS="PyKeyword">def</SPAN> <SPAN CLASS="FunctionName">Object.OwnerObject.owned_by</SPAN></A>(<SPAN CLASS="Argument">self</SPAN>)<SPAN CLASS="OneLiner"> # returns the name of the parent attribute</SPAN>
    <A CLASS="DocLink" HREF="#Object.OwnerObject.remove_other_references"><SPAN CLASS="PyKeyword">def</SPAN> <SPAN CLASS="FunctionName">Object.OwnerObject.remove_other_references</SPAN></A>(<SPAN CLASS="Argument">self</SPAN>)

</PRE><H2>Description</H2><P>
base class for new generic GUI editor which can function as an
interface to the mediator simulation, or as a test client</P>
<P>
<STRONG>CLASS ATTRIBUTES</STRONG></P>
<P>
<EM>none</EM></P>
<P>
<STRONG>INSTANCE ATTRIBUTES</STRONG></P>

<DL>

<DT>
<EM>AppState app_control</EM>
<DD>reference to the parent
AppState object, which requires certain callbacks

</DL>
<H2 ID="GenEdit.GenEdit.__init__" CLASS="Method">GenEdit.GenEdit.__init__(<SPAN CLASS="Argument">self</SPAN>, <SPAN CLASS="Argument">**args</SPAN>)</H2>
<P>None</P>

<P>
<STRONG>Note:</STRONG> GenEdit requires the app_control attribute to
perform the appropriate callbacks to AppState.  However, since 
AppStateGenEdit can't be constructed without a reference to an 
existing GenEdit, AppStateGenEdit.__init__ will call 
set_app_control to set its value.</P>
<H2 ID="GenEdit.GenEdit.active_frame" CLASS="Method">GenEdit.GenEdit.active_frame(<SPAN CLASS="Argument">self</SPAN>)</H2>
<P>returns the currently active frame, if any</P>

<P>
<STRONG>INPUTS</STRONG> </P>
<P>
<EM>none</EM></P>
<P>
<STRONG>OUTPUTS</STRONG></P>

<DL>

<DT>
<EM>GenEditFrame</EM>
<DD>the currently active frame, or None if
no frame of the editor is active.

</DL>
<H2 ID="GenEdit.GenEdit.app_active_buffer_name" CLASS="Method">GenEdit.GenEdit.app_active_buffer_name(<SPAN CLASS="Argument">self</SPAN>)</H2>
<P>None</P>

<P>
Returns the name of the buffer currently active in the
GenEdit editor.</P>
<P>
<STRONG>INPUTS</STRONG></P>
<P>
<EM>none</EM> </P>
<P>
<STRONG>OUTPUTS</STRONG></P>

<DL>

<DT>
<EM>STR</EM>
<DD>buffer name of current buffer, or None if there is none
</DL>
<H2 ID="GenEdit.GenEdit.app_change_buffer" CLASS="Method">GenEdit.GenEdit.app_change_buffer(<SPAN CLASS="Argument">self</SPAN>, <SPAN CLASS="Argument">buff_name</SPAN>)</H2>
<P>Changes the external application's active buffer.</P>

<P>
<STRONG>INPUTS</STRONG></P>

<DL>

<DT>
STR <EM>buff_name</EM>
<DD>Name of the buffer to switch to.
</DL>
<P>
<STRONG>OUTPUTS</STRONG></P>

<DL>

<DT>
<EM>BOOL</EM>
<DD>true if buff_name exists and the application
successfully switches to it

</DL>
<H2 ID="GenEdit.GenEdit.app_close_buffer" CLASS="Method">GenEdit.GenEdit.app_close_buffer(<SPAN CLASS="Argument">self</SPAN>, <SPAN CLASS="Argument">buff_name</SPAN>, <SPAN CLASS="Argument">save=0</SPAN>)</H2>
<P>Close a buffer.</P>

<P>
<STRONG>INPUTS</STRONG></P>

<DL>

<DT>
STR <EM>buff_name</EM>
<DD>name of buffer to close
<DT>
INT <EM>save</EM>
<DD><EM>-1</EM> -&gt; don't save the buffer
                    <EM>0</EM> -&gt; query user if buffer needs saving
                    <EM>1</EM> -&gt; save without querying user
</DL>
<P>
<STRONG>OUTPUTS</STRONG></P>

<DL>

<DT>
<EM>BOOL</EM>
<DD>true if the editor does close the buffer

</DL>
<H2 ID="GenEdit.GenEdit.editor_buffer" CLASS="Method">GenEdit.GenEdit.editor_buffer(<SPAN CLASS="Argument">self</SPAN>, <SPAN CLASS="Argument">buff_name</SPAN>)</H2>
<P>None</P>

<P>
returns a reference to the TextBufferChangeSpec embedded 
in the GUI which corresponds to buffer buff_name</P>
<P>
<STRONG>INPUTS</STRONG></P>

<DL>

<DT>
<EM>STR buff_name</EM>
<DD>the name of the buffer
</DL>
<P>
<STRONG>OUTPUTS</STRONG></P>

<DL>

<DT>
<EM>TextBufferChangeSpec</EM>
<DD>the TextBufferChangeSpec

</DL>
<H2 ID="GenEdit.GenEdit.editor_has_focus" CLASS="Method">GenEdit.GenEdit.editor_has_focus(<SPAN CLASS="Argument">self</SPAN>)</H2>
<P>indicates whether the editor window has the focus</P>

<P>
<STRONG>INPUTS</STRONG></P>
<P>
<EM>none</EM></P>
<P>
<STRONG>OUTPUTS</STRONG>
<EM>BOOL</EM> -- true if editor window has the focus
</P>
<H2 ID="GenEdit.GenEdit.file_name" CLASS="Method">GenEdit.GenEdit.file_name(<SPAN CLASS="Argument">self</SPAN>, <SPAN CLASS="Argument">buff_name</SPAN>)</H2>
<P>returns the current filename associated with a given buffer</P>

<P>
<STRONG>INPUTS</STRONG></P>

<DL>

<DT>
<EM>STR buff_name</EM>
<DD>the name of the buffer
</DL>
<P>
<STRONG>OUTPUTS</STRONG></P>

<DL>

<DT>
<EM>STR</EM>
<DD>the filename

</DL>
<H2 ID="GenEdit.GenEdit.is_active" CLASS="Method">GenEdit.GenEdit.is_active(<SPAN CLASS="Argument">self</SPAN>)</H2>
<P>indicates whether an editor frame is active</P>

<P>
<STRONG>INPUTS</STRONG></P>
<P>
<EM>none</EM></P>
<P>
<STRONG>OUTPUTS</STRONG></P>

<DL>

<DT>
<EM>BOOL</EM>
<DD>true if frame window is active

</DL>
<H2 ID="GenEdit.GenEdit.mic_change" CLASS="Method">GenEdit.GenEdit.mic_change(<SPAN CLASS="Argument">self</SPAN>, <SPAN CLASS="Argument">state</SPAN>)</H2>
<P>function to receive microphone state change callbacks</P>

<P>
<STRONG>INPUTS</STRONG></P>

<DL>

<DT>
<EM>STR</EM> state
<DD>new state ('on', <CODE>off</CODE>, <CODE>sleeping</CODE>, 'disabled')
</DL>
<P>
<STRONG>OUTPUTS</STRONG></P>
<P>
<EM>none</EM>
</P>
<H2 ID="GenEdit.GenEdit.multiple_buffers" CLASS="Method">GenEdit.GenEdit.multiple_buffers(<SPAN CLASS="Argument">self</SPAN>)</H2>
<P>does editor support multiple open buffers?</P>

<P>
<STRONG>INPUTS</STRONG></P>
<P>
<EM>none</EM></P>
<P>
<STRONG>OUTPUTS</STRONG></P>

<DL>

<DT>
<EM>BOOL</EM>
<DD>true if editor supports having multiple buffers open 
at the same time
</DL>
<H2 ID="GenEdit.GenEdit.multiple_windows" CLASS="Method">GenEdit.GenEdit.multiple_windows(<SPAN CLASS="Argument">self</SPAN>)</H2>
<P>does editor support multiple windows per instance?</P>

<P>
Note: the purpose of this function is to allow the RecogStartMgr
to determine whether a previously unknown window could belong to
this known instance.  Therefore, Emacs running in text mode 
should return false, even though it can have (sub-)windows in 
a single frame.  </P>
<P>
Note: multiple windows of remote editors running in a remote display
which appears as a single window to be local operating system 
(X servers in single window mode, VNC) will not appear to the mediator 
as having separate windows.  However, the mediator will perform a 
separate check to detect this, so remote editors which support
multiple windows should return true, regardless of the remote
display method.</P>
<P>
<STRONG>INPUTS</STRONG></P>
<P>
<EM>none</EM></P>
<P>
<STRONG>OUTPUTS</STRONG></P>

<DL>

<DT>
<EM>BOOL</EM>
<DD>true if editor supports opening multiple editor windows.  

</DL>
<H2 ID="GenEdit.GenEdit.new_buffer" CLASS="Method">GenEdit.GenEdit.new_buffer(<SPAN CLASS="Argument">self</SPAN>, <SPAN CLASS="Argument">buff_name</SPAN>, <SPAN CLASS="Argument">buffer</SPAN>, <SPAN CLASS="Argument">perform_callback=1</SPAN>)</H2>
<P>None</P>

<P>
adds a new buffer, optionally performing a callback to the
AppState interface</P>
<P>
<STRONG>INPUTS</STRONG></P>

<DL>

<DT>
<EM>STR buff_name</EM>
<DD>the name of the new buffer
<DT>
<EM>TextBufferChangeSpec buffer</EM>
<DD>the TextBufferChangeSpec 
interface to the new buffer
<DT>
<EM>BOOL perform_callback</EM>
<DD>indicates whether this method should
invoke the parent AppState's open buffer callback
</DL>
<P>
<STRONG>OUTPUTS</STRONG></P>

<DL>

<DT>
<EM>BOOL</EM>
<DD>true if the new buffer was added successfully

</DL>
<H2 ID="GenEdit.GenEdit.on_exit" CLASS="Method">GenEdit.GenEdit.on_exit(<SPAN CLASS="Argument">self</SPAN>, <SPAN CLASS="Argument">ID=None</SPAN>)</H2>
<P>None</P>

<P>
method by which a frame can notify GenEdit that the user has
selected the Exit item from the File menu.  The user may have an 
opportunity to cancel this command (e.g. through the cancel button
in a dialog prompting to save modified files)</P>
<P>
<STRONG>NOTE:</STRONG> GenEdit is responsible for telling all frames to
cleanup and close, so the calling should not assume that
it is in a sane state when this method returns.</P>

<DL>

<DT>
<EM>BOOL</EM>
<DD>true if the editor is exiting in response to this
event (unless, e.g., the user has hit cancel in response to a 
save modified files dialog)
</DL>
<P>
<STRONG>INPUTS</STRONG></P>

<DL>

<DT>
<EM>INT ID</EM>
<DD>ID of the frame sending the event, or None if the
event doesn't originate from a frame.
</DL>
<P>
<STRONG>OUTPUTS</STRONG></P>
<P>
<EM>none</EM>
</P>
<H2 ID="GenEdit.GenEdit.open_buffers" CLASS="Method">GenEdit.GenEdit.open_buffers(<SPAN CLASS="Argument">self</SPAN>)</H2>
<P>None</P>

<P>
retrieve a list of the names of open buffers from the
application.</P>
<P>
<STRONG>INPUTS</STRONG></P>
<P>
<EM>none</EM></P>
<P>
<STRONG>OUTPUTS</STRONG></P>

<DL>

<DT>
<EM>[STR]</EM>
<DD>list of the names of open buffers

</DL>
<H2 ID="GenEdit.GenEdit.open_file" CLASS="Method">GenEdit.GenEdit.open_file(<SPAN CLASS="Argument">self</SPAN>, <SPAN CLASS="Argument">file_name</SPAN>, <SPAN CLASS="Argument">perform_callback=0</SPAN>)</H2>
<P>opens a new file </P>

<P>
<STRONG>INPUTS</STRONG></P>

<DL>

<DT>
<EM>STR file_name</EM> 
<DD>the full path of the file to open
<DT>
<EM>BOOL user_initiated</EM>
<DD>indicates whether this method was
user-initiated or whether it was called by AppState.
In the latter case, it will not invoke the parent AppState's 
open buffer callback, because AppState.open_file invokes 
the callback itself. 
</DL>
<P>
<STRONG>OUTPUTS</STRONG></P>

<DL>

<DT>
STR <EM>buff_name</EM>
<DD>Unique name of the buffer in which the file
was opened. Returns <EM>None</EM> if the editor was not able to open
the file.

</DL>
<H2 ID="GenEdit.GenEdit.open_file_dialog" CLASS="Method">GenEdit.GenEdit.open_file_dialog(<SPAN CLASS="Argument">self</SPAN>)</H2>
<P>prompts for a file to open</P>

<P>
<STRONG>INPUTS</STRONG></P>
<P>
<EM>none</EM></P>
<P>
<STRONG>OUTPUTS</STRONG></P>

<DL>

<DT>
<EM>STR</EM>
<DD>the specified path, or None if the user cancelled 

</DL>
<H2 ID="GenEdit.GenEdit.overwrite_prompt" CLASS="Method">GenEdit.GenEdit.overwrite_prompt(<SPAN CLASS="Argument">self</SPAN>, <SPAN CLASS="Argument">buff_name</SPAN>, <SPAN CLASS="Argument">full_path</SPAN>)</H2>
<P>None</P>

<P>
prompts to see if the user is sure that he/she wants to
overwrite an existing file</P>
<P>
<STRONG>INPUTS</STRONG></P>

<DL>

<DT>
<EM>STR buff_name</EM>
<DD>the name of the buffer (used to find the
corresponding frame over which to pop up the Save As dialog)
<DT>
<EM>STR full_path</EM>
<DD>path name of file to save
</DL>
<P>
<STRONG>OUTPUTS</STRONG></P>

<DL>

<DT>
<EM>BOOL</EM>
<DD>true if the user approves of overwriting the file

</DL>
<H2 ID="GenEdit.GenEdit.prompt_to_save" CLASS="Method">GenEdit.GenEdit.prompt_to_save(<SPAN CLASS="Argument">self</SPAN>, <SPAN CLASS="Argument">buff_name</SPAN>)</H2>
<P>None</P>

<P>
prompts the user to save the current buffer before closing it, 
or cancel.  Note: prompt_to_save should save if the user so
indicates, and update the entry in self.filenames corresponding
to the buffer, but should not close the buffer, because
open_file could still fail.</P>
<P>
<STRONG>INPUTS</STRONG></P>

<DL>

<DT>
<EM>STR buff_name</EM>
<DD>the name of the buffer
</DL>
<P>
<STRONG>OUTPUTS</STRONG></P>

<DL>

<DT>
<EM>BOOL</EM>
<DD>true if the user saved or told GenEdit to proceed
without saving, false if the user asked for the action causing
the buffer closing to be cancelled.

</DL>
<H2 ID="GenEdit.GenEdit.rename_buffer" CLASS="Method">GenEdit.GenEdit.rename_buffer(<SPAN CLASS="Argument">self</SPAN>, <SPAN CLASS="Argument">buff_name</SPAN>, <SPAN CLASS="Argument">new_buff_name</SPAN>, <SPAN CLASS="Argument">perform_callback=1</SPAN>)</H2>
<P>None</P>

<P>
renames a buffer, optionally performing a callback to the
AppState interface</P>
<P>
<STRONG>INPUTS</STRONG></P>

<DL>

<DT>
<EM>STR buff_name</EM>
<DD>the old name of the new buffer
<DT>
<EM>STR new_buff_name</EM>
<DD>the new name of the new buffer
<DT>
<EM>BOOL perform_callback</EM>
<DD>indicates whether this method should
invoke the parent AppState's rename buffer callback
</DL>
<P>
<STRONG>OUTPUTS</STRONG></P>

<DL>

<DT>
<EM>BOOL</EM>
<DD>true if the new buffer was renamed successfully

</DL>
<H2 ID="GenEdit.GenEdit.save_as_dialog" CLASS="Method">GenEdit.GenEdit.save_as_dialog(<SPAN CLASS="Argument">self</SPAN>, <SPAN CLASS="Argument">buff_name</SPAN>)</H2>
<P>None</P>

<P>
prompts for a filename under which to save the file, and
confirms overwriting</P>
<P>
<STRONG>INPUTS</STRONG></P>

<DL>

<DT>
<EM>STR buff_name</EM>
<DD>the name of the buffer (used to find the
corresponding frame over which to pop up the Save As dialog)
</DL>
<P>
<STRONG>OUTPUTS</STRONG></P>

<DL>

<DT>
<EM>STR</EM>
<DD>the specified path, or None if the user cancelled 

</DL>
<H2 ID="GenEdit.GenEdit.save_file" CLASS="Method">GenEdit.GenEdit.save_file(<SPAN CLASS="Argument">self</SPAN>, <SPAN CLASS="Argument">buff_name</SPAN>, <SPAN CLASS="Argument">full_path=None</SPAN>, <SPAN CLASS="Argument">no_prompt=0</SPAN>, <SPAN CLASS="Argument">rename_buff=1</SPAN>, <SPAN CLASS="Argument">ask_for_new_name=0</SPAN>, <SPAN CLASS="Argument">perform_callback=0</SPAN>)</H2>
<P>Saves the buffer buff_name to a file</P>

<P>
<STRONG>INPUTS</STRONG></P>

<DL>

<DT>
<EM>STR buff_name</EM>
<DD>the name of the buffer
<DT>
<EM>STR full_path</EM>
<DD>path name of file to save, or None to use the
current file name, or prompt
<DT>
<EM>BOOL no_prompt</EM>
<DD>if true, don't prompt before overwriting
an existing file.
<DT>
<EM>BOOL rename_buff</EM>
<DD>if false, do not rename the buffer
<DT>
<EM>BOOL ask_for_new_name</EM>
<DD>if true, prompt for a new name, even if the
buffer already has a corresponding filename.  Ignored unless
full_path == None.
<DT>
<EM>BOOL perform_callback</EM>
<DD>indicates whether this method should
invoke the parent AppState's rename buffer callback.  AppState
should use the default value of false, because
AppState.save_file invokes the callback itself, but 
save_file initiated from the frame by the user must 
use perform_callback = 1
</DL>
<P>
<STRONG>OUTPUTS</STRONG></P>

<DL>

<DT>
<EM>STR</EM>
<DD>new buffer name if successful, or None if the save 
failed

</DL>
<H2 ID="GenEdit.GenEdit.set_app_control" CLASS="Method">GenEdit.GenEdit.set_app_control(<SPAN CLASS="Argument">self</SPAN>, <SPAN CLASS="Argument">app_control</SPAN>)</H2>
<P>None</P>

<P>
method called by app_control's (AppStateGenEdit.) __init__ 
to supply reference to itself, so that GenEdit can perform
callbacks.</P>
<P>
<STRONG>INPUTS</STRONG></P>

<DL>

<DT>
<EM>AppStateGenEdit app_control</EM>
<DD>the AppState interface
</DL>
<P>
<STRONG>OUTPUTS</STRONG></P>
<P>
<EM>none</EM>
</P>
<H2 ID="GenEdit.GenEdit.set_instance_string" CLASS="Method">GenEdit.GenEdit.set_instance_string(<SPAN CLASS="Argument">self</SPAN>, <SPAN CLASS="Argument">instance_string</SPAN>)</H2>
<P>None</P>

<P>
sets the title string which is included in the full title 
displayed in the title bar</P>
<P>
<STRONG>INPUTS</STRONG></P>

<DL>

<DT>
<EM>STR</EM> instance_string
<DD>string to include as part of the title
</DL>
<P>
<STRONG>OUTPUTS</STRONG></P>

<DL>

<DT>
<EM>BOOL</EM>
<DD>true if the editor can and will include the 
instance string in its window title for all windows 
containing editor buffers.

</DL>
<H2 ID="Object.Object.decl_attrs" CLASS="Method">Object.Object.decl_attrs(<SPAN CLASS="Argument">self</SPAN>, <SPAN CLASS="Argument">attrs</SPAN>)</H2>
<P>Define new attributes for <EM>self</EM></P>

<P>
Attributes are directly through self.__dict__, thus bypassing safe
__setattr__.</P>
<P>
<STRONG>INPUTS</STRONG></P>

<DL>

<DT>
<EM>{STR: ANY}</EM> attrs
<DD>dictionary with attribute name as the keys and
 initial values as the values.
</DL>
<P>
<STRONG>OUTPUTS</STRONG></P>

<DL>

<DT>
<EM>none</EM>
<DD>
</DL>
<H2 ID="Object.Object.deep_construct" CLASS="Method">Object.Object.deep_construct(<SPAN CLASS="Argument">self</SPAN>, <SPAN CLASS="Argument">this_class</SPAN>, <SPAN CLASS="Argument">attrs_this_class</SPAN>, <SPAN CLASS="Argument">args_super</SPAN>, <SPAN CLASS="Argument">new_default={}</SPAN>, <SPAN CLASS="Argument">enforce_value={}</SPAN>, <SPAN CLASS="Argument">exclude_bases={}</SPAN>)</H2>
<P>Build an instance of a class.</P>

<P>
Basically, this method:
- declares and initialise all attributes listed in <EM>attrs_this_class</EM>
- invokes the <EM>__init__</EM> of all superclasses (with the exclusion of those listed in *exclude_bases*), passing them arguments in <EM>args_super</EM></P>

<DL>

<DT>
<EM>CLASS</EM> this_class
<DD>Class that we want to build. This is a
 class object as opposed to the name of a class. Constructors
 of immediate superclasses of <EM>this_class</EM> are called
 automatically, except if they are listed in *{CLASS: 1}
 exclude_bases*.
<DT>
<EM>{STR: ANY}</EM> attrs_this_class
<DD>New attributes (and their
 values) defined by class <EM>this_class</EM>. The keys are the names
 of the attributes and the values are the values of the
 attributes (either default values or values passed to
 *this_class.__init__*). An attribute with the appropriate
 name will be declared automatically and initialsed to the
 value specified in <EM>attrs_this_class</EM>.
<DT>
<EM>{STR: ANY}</EM> args_super
<DD>Arguments received by
<EM>this_class.__init__</EM> but not recognised by it. These are
assumed to be arguments defined in the <EM>__init__</EM> of some
ancestor class and are just passed up the construction
chain. Keys of <EM>args_super</EM> correspond to the names of the
arguments and the values corresponds to the values received
for them by <EM>this_class.__init__</EM>
<DT>
<EM>{STR: ANY}</EM> new_default={}
<DD>Used to change the default
 value of an ancestor constructor argument. In other words, if
 <EM>this_class.__init__</EM> was called without specifying a value
 for an argument that's listed in <EM>new_default</EM>, the default
 value defined in <EM>new_default</EM> will be used instead of
 whatever default might be defined in the constructor
 of an ancestor class. However, if the constructor was called
 WITH a specific value for that argument, that specific value
 will be used instead of both the defaults defined in
 <EM>new_default</EM> and the constructor of ancestor classes. Keys
 of <EM>new_default</EM> correspond to argument names, and values
 correspond to the new default values. If you don't specify a
 value of <EM>new_default</EM>, it defaults to <EM>{}</EM>, which means that
 the defaults of none of the ancestor constructor arguments
 are redefined by <EM>this_class</EM>.
<DT>
<EM>{STR: ANY}</EM> enforce_value={}
<DD>Lists of arguments with
 enforced values. If the constructor is called with a value
 for an argument that is different from the value specified
 for it in <EM>enforce_value</EM>, then an <A HREF="Object.EnforcedConstrArg.html">EnforcedConstrArg</A>
 exception will be raised. Also, if the constructor is called
 without specifying a value for a particular argument, then
 the value defined in <EM>enforce_value</EM> (if it exists) will be
 used instead of whatever default might be defined in an
 ancestor class. Keys of <EM>enforce_value</EM> correspond to
 argument names and values correspond to the enforced
 values. If you don't specify a value for <EM>enforce_value</EM>, it
 defaults to <EM>{}</EM>, which means that <EM>this_class.__init__</EM> does
 not enforce the value of any argument.
<DT>
<EM>{CLASS: BOOL}</EM> exclude_bases
<DD>Immediate base classes whose
constructors should not be called automatically. If an
immediate superclass of <EM>this_class</EM> is listed in
<EM>exclude_bases</EM>, then we don't automatically call its
constructor. It is assumed that the programmer will call the
constructor manually in <EM>this_class.__init__</EM>. If you do not
specify a value for <EM>exclude_bases</EM>, it will default to <EM>{}</EM>,
which means that the constructor of all immediate super
classes will be called automatically.
</DL>
<H2 ID="Object.Object.init_attrs" CLASS="Method">Object.Object.init_attrs(<SPAN CLASS="Argument">self</SPAN>, <SPAN CLASS="Argument">attrs</SPAN>)</H2>
<P>Initialises existing attributes</P>

<P>
Attributes are only set if they already exist in
 <EM>self.__dict__</EM>. Otherwise, an <EM>AttributeError</EM> exception is
 raised (provided PY_DEBUG_OBJECT=1).</P>
<P>
<STRONG>INPUTS</STRONG></P>

<DL>

<DT>
<EM>{STR: ANY}</EM> attrs
<DD>dictionary with attribute name as the keys and
 default values as the values.
</DL>
<P>
<STRONG>OUTPUTS</STRONG></P>

<DL>

<DT>
<EM>none</EM>
<DD>
</DL>
<H2 ID="Object.Object.possibly_init_attrs" CLASS="Method">Object.Object.possibly_init_attrs(<SPAN CLASS="Argument">self</SPAN>, <SPAN CLASS="Argument">attrs</SPAN>)</H2>
<P>None</P>

<P>
Initialises existing attributes, unless those attributes
already exist</P>
<P>
<STRONG>INPUTS</STRONG></P>

<DL>

<DT>
<EM>{STR: ANY}</EM> attrs
<DD>dictionary with attribute name as the keys and
 default values as the values.
</DL>
<P>
<STRONG>OUTPUTS</STRONG></P>

<DL>

<DT>
<EM>none</EM>
<DD>
</DL>
<H2 ID="Object.OwnerObject._cleanup_object" CLASS="Method">Object.OwnerObject._cleanup_object(<SPAN CLASS="Argument">self</SPAN>, <SPAN CLASS="Argument">object</SPAN>)</H2>
<P>attempt to call cleanup on object</P>

<P>
<STRONG>INPUTS*</STRONG></P>

<DL>

<DT>
<EM>OwnerObject object</EM>
<DD>note: class of object is the expected
class, but _cleanup_object doesn't assume this is correct, nor
does it check whether the object is a subclass of
OwnerObject, only that it is a class instance and that it
has a cleanup attribute
</DL>
<P>
<STRONG>OUTPUTS</STRONG></P>

<DL>

<DT>
<EM>STR</EM>
<DD>reason for error (or None if no error).

</DL>
<H2 ID="Object.OwnerObject.add_grandparent" CLASS="Method">Object.OwnerObject.add_grandparent(<SPAN CLASS="Argument">self</SPAN>, <SPAN CLASS="Argument">grandparent</SPAN>)</H2>
<P>None</P>

<P>
specify the name of the attribute containing a reference to 
this object's grandparent (or great-grandparent, etc.)
(Actually, any other reference which needs to be del'ed but not
cleaned up)</P>
<P>
<STRONG>INPUTS</STRONG></P>

<DL>

<DT>
<EM>STR grandparent</EM>
<DD>names of owned attributes
</DL>
<P>
<STRONG>OUTPUTS</STRONG></P>
<P>
<EM>none</EM>
</P>
<H2 ID="Object.OwnerObject.add_owned" CLASS="Method">Object.OwnerObject.add_owned(<SPAN CLASS="Argument">self</SPAN>, <SPAN CLASS="Argument">owned</SPAN>)</H2>
<P>append a new attribute name to the list of owned objects</P>

<P>
<STRONG>INPUTS</STRONG></P>

<DL>

<DT>
<EM>STR owned</EM>
<DD>names of owned attributes
</DL>
<P>
<STRONG>OUTPUTS</STRONG></P>
<P>
<EM>none</EM>
</P>
<H2 ID="Object.OwnerObject.add_owned_list" CLASS="Method">Object.OwnerObject.add_owned_list(<SPAN CLASS="Argument">self</SPAN>, <SPAN CLASS="Argument">owned</SPAN>)</H2>
<P>append new attribute names to the list of owned objects</P>

<P>
<STRONG>INPUTS</STRONG></P>

<DL>

<DT>
<EM>[STR] owned</EM>
<DD>names of owned attributes
</DL>
<P>
<STRONG>OUTPUTS</STRONG></P>
<P>
<EM>none</EM>
</P>
<H2 ID="Object.OwnerObject.cleanup" CLASS="Method">Object.OwnerObject.cleanup(<SPAN CLASS="Argument">self</SPAN>)</H2>
<P>None</P>

<P>
method to cleanup circular references by cleaning up 
any children, and then removing the reference to the parent</P>
<P>
<STRONG>INPUTS</STRONG></P>
<P>
<EM>none</EM></P>
<P>
<STRONG>OUTPUTS</STRONG></P>
<P>
<EM>none</EM>
</P>
<H2 ID="Object.OwnerObject.name_parent" CLASS="Method">Object.OwnerObject.name_parent(<SPAN CLASS="Argument">self</SPAN>, <SPAN CLASS="Argument">parent=None</SPAN>)</H2>
<P>None</P>

<P>
specify the name of the attribute containing a reference to 
this object's parent.</P>
<P>
<STRONG>INPUTS</STRONG></P>

<DL>

<DT>
<EM>STR parent</EM>
<DD>name of the parent, or None if none
</DL>
<P>
<STRONG>OUTPUTS</STRONG></P>
<P>
<EM>none</EM>
</P>
<H2 ID="Object.OwnerObject.owned_by" CLASS="Method">Object.OwnerObject.owned_by(<SPAN CLASS="Argument">self</SPAN>)</H2>
<P>returns the name of the parent attribute</P>

<P>
<STRONG>INPUTS</STRONG></P>
<P>
<EM>none</EM></P>
<P>
<STRONG>OUTPUTS</STRONG></P>

<DL>

<DT>
<EM>STR</EM>
<DD>name of the parent, or None if none

</DL>
<H2 ID="Object.OwnerObject.remove_other_references" CLASS="Method">Object.OwnerObject.remove_other_references(<SPAN CLASS="Argument">self</SPAN>)</H2>
<P>None</P>

<P>
additional cleanup to ensure that this object's references to
its owned objects are the last remaining references</P>
<P>
<STRONG>NOTE:</STRONG> subclasses must call their parent class's 
remove_other_references method, after performing their own duties.
Also, a class inheriting from two OwnerObject classes MUST
define remove_other_references and call both subclasses'
versions</P>
<P>
<STRONG>INPUTS</STRONG></P>
<P>
<EM>none</EM></P>
<P>
<STRONG>OUTPUTS</STRONG></P>
<P>
<EM>none</EM>
</P>

<HR>
<TABLE ALIGN="LEFT">
<TR><TD>
  <A HREF="http://validator.w3.org/check/referer" TARGET="validate">
    <IMG BORDER=0 SRC="http://validator.w3.org/images/vh40.gif"
     ALT="Valid HTML 4.0!" HEIGHT=31 WIDTH=88></A>
  <A HREF="http://www.w3.org/Style/CSS/Buttons">
    <IMG ALT="Made with CSS" BORDER=0 WIDTH=88 HEIGHT=31 
     SRC="http://www.w3.org/Style/CSS/Buttons/mwcos"></A>

</TD>
<TD STYLE="padding-left: 10">
  <SPAN CLASS="AUTHOR"></SPAN><BR>
  <SPAN CLASS="VERSION"></SPAN>
</TD>
</TABLE>

</body>
</html>
