<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.0 Transitional//EN" "http://www.w3.org/TR/REC-html40/loose.dtd">
<html>

<head>

<META NAME="GENERATOR" CONTENT="pythondoc 0.7 (Sat Feb 01 16:35:51 2003)">

<link rel="stylesheet" href="pythondoc.css" type="text/css">

<title>Class SB_ServiceState</title>
</head>

<body>
<P><A HREF="index.html">Table of contents</A> <A HREF="indices.html">Index</A></P>


<H1 CLASS="ClassName">class SB_ServiceState</H1>
<P CLASS="DeclaredIn">Declared in module <A HREF="sb_services.html">sb_services</A></P>

<H2 CLASS="ClassHierarchy">Inheritance hierarchy:</H2><P CLASS="ClassHierarchy">sb_services.SB_ServiceState<BR>
&nbsp;&nbsp;<A HREF="sb_services.SB_Service.html">sb_services.SB_Service</A><BR>
&nbsp;&nbsp;&nbsp;&nbsp;Object.OwnerObject<BR>
</P>

<H2>Synopsis</H2>
<PRE CLASS="ClassDeclaration">
<SPAN CLASS="PyKeyword">class</SPAN> <SPAN CLASS="ClassName">SB_ServiceState</SPAN>(<A CLASS="DocLink" HREF="sb_services.SB_Service.html">SB_Service</A>):
    <SPAN CLASS="PyKeyword">def</SPAN> <SPAN CLASS="FunctionName">sb_services.SB_ServiceState.__init__</SPAN>(<SPAN CLASS="Argument">self</SPAN>, <SPAN CLASS="Argument">**args_super</SPAN>)
    <A CLASS="DocLink" HREF="#sb_services.SB_ServiceState._state_cookie_class"><SPAN CLASS="PyKeyword">def</SPAN> <SPAN CLASS="FunctionName">sb_services.SB_ServiceState._state_cookie_class</SPAN></A>(<SPAN CLASS="Argument">self</SPAN>)
    <A CLASS="DocLink" HREF="#sb_services.SB_ServiceState.compare_selection_with_current"><SPAN CLASS="PyKeyword">def</SPAN> <SPAN CLASS="FunctionName">sb_services.SB_ServiceState.compare_selection_with_current</SPAN></A>(<SPAN CLASS="Argument">self</SPAN>, <SPAN CLASS="Argument">cookie</SPAN>)
    <A CLASS="DocLink" HREF="#sb_services.SB_ServiceState.compare_state_selections"><SPAN CLASS="PyKeyword">def</SPAN> <SPAN CLASS="FunctionName">sb_services.SB_ServiceState.compare_state_selections</SPAN></A>(<SPAN CLASS="Argument">self</SPAN>, <SPAN CLASS="Argument">first_cookie</SPAN>, <SPAN CLASS="Argument">second_cookie</SPAN>)
    <A CLASS="DocLink" HREF="#sb_services.SB_ServiceState.compare_states"><SPAN CLASS="PyKeyword">def</SPAN> <SPAN CLASS="FunctionName">sb_services.SB_ServiceState.compare_states</SPAN></A>(<SPAN CLASS="Argument">self</SPAN>, <SPAN CLASS="Argument">first_cookie</SPAN>, <SPAN CLASS="Argument">second_cookie</SPAN>, <SPAN CLASS="Argument">selection=0</SPAN>)
    <A CLASS="DocLink" HREF="#sb_services.SB_ServiceState.compare_with_current"><SPAN CLASS="PyKeyword">def</SPAN> <SPAN CLASS="FunctionName">sb_services.SB_ServiceState.compare_with_current</SPAN></A>(<SPAN CLASS="Argument">self</SPAN>, <SPAN CLASS="Argument">cookie</SPAN>, <SPAN CLASS="Argument">selection=0</SPAN>)
    <A CLASS="DocLink" HREF="#sb_services.SB_ServiceState.get_state_pos_selection"><SPAN CLASS="PyKeyword">def</SPAN> <SPAN CLASS="FunctionName">sb_services.SB_ServiceState.get_state_pos_selection</SPAN></A>(<SPAN CLASS="Argument">self</SPAN>, <SPAN CLASS="Argument">cookie</SPAN>)
    <A CLASS="DocLink" HREF="#sb_services.SB_ServiceState.restore_state"><SPAN CLASS="PyKeyword">def</SPAN> <SPAN CLASS="FunctionName">sb_services.SB_ServiceState.restore_state</SPAN></A>(<SPAN CLASS="Argument">self</SPAN>, <SPAN CLASS="Argument">cookie</SPAN>)
    <A CLASS="DocLink" HREF="#sb_services.SB_ServiceState.store_current_state"><SPAN CLASS="PyKeyword">def</SPAN> <SPAN CLASS="FunctionName">sb_services.SB_ServiceState.store_current_state</SPAN></A>(<SPAN CLASS="Argument">self</SPAN>)
    <A CLASS="DocLink" HREF="#sb_services.SB_ServiceState.valid_cookie"><SPAN CLASS="PyKeyword">def</SPAN> <SPAN CLASS="FunctionName">sb_services.SB_ServiceState.valid_cookie</SPAN></A>(<SPAN CLASS="Argument">self</SPAN>, <SPAN CLASS="Argument">cookie</SPAN>)

    <SPAN CLASS="InheritsHead"># Inherited from Object.OwnerObject</SPAN>
    <SPAN CLASS="PyKeyword">def</SPAN> <SPAN CLASS="FunctionName">Object.OwnerObject.__init__</SPAN>(<SPAN CLASS="Argument">self</SPAN>, <SPAN CLASS="Argument">**attrs</SPAN>)
    <A CLASS="DocLink" HREF="#Object.OwnerObject._cleanup_object"><SPAN CLASS="PyKeyword">def</SPAN> <SPAN CLASS="FunctionName">Object.OwnerObject._cleanup_object</SPAN></A>(<SPAN CLASS="Argument">self</SPAN>, <SPAN CLASS="Argument">object</SPAN>)<SPAN CLASS="OneLiner"> # attempt to call cleanup on object</SPAN>
    <A CLASS="DocLink" HREF="#Object.OwnerObject.add_grandparent"><SPAN CLASS="PyKeyword">def</SPAN> <SPAN CLASS="FunctionName">Object.OwnerObject.add_grandparent</SPAN></A>(<SPAN CLASS="Argument">self</SPAN>, <SPAN CLASS="Argument">grandparent</SPAN>)
    <A CLASS="DocLink" HREF="#Object.OwnerObject.add_owned"><SPAN CLASS="PyKeyword">def</SPAN> <SPAN CLASS="FunctionName">Object.OwnerObject.add_owned</SPAN></A>(<SPAN CLASS="Argument">self</SPAN>, <SPAN CLASS="Argument">owned</SPAN>)<SPAN CLASS="OneLiner"> # append a new attribute name to the list of owned objects</SPAN>
    <A CLASS="DocLink" HREF="#Object.OwnerObject.add_owned_list"><SPAN CLASS="PyKeyword">def</SPAN> <SPAN CLASS="FunctionName">Object.OwnerObject.add_owned_list</SPAN></A>(<SPAN CLASS="Argument">self</SPAN>, <SPAN CLASS="Argument">owned</SPAN>)<SPAN CLASS="OneLiner"> # append new attribute names to the list of owned objects</SPAN>
    <A CLASS="DocLink" HREF="#Object.OwnerObject.cleanup"><SPAN CLASS="PyKeyword">def</SPAN> <SPAN CLASS="FunctionName">Object.OwnerObject.cleanup</SPAN></A>(<SPAN CLASS="Argument">self</SPAN>)
    <A CLASS="DocLink" HREF="#Object.OwnerObject.name_parent"><SPAN CLASS="PyKeyword">def</SPAN> <SPAN CLASS="FunctionName">Object.OwnerObject.name_parent</SPAN></A>(<SPAN CLASS="Argument">self</SPAN>, <SPAN CLASS="Argument">parent=None</SPAN>)
    <A CLASS="DocLink" HREF="#Object.OwnerObject.owned_by"><SPAN CLASS="PyKeyword">def</SPAN> <SPAN CLASS="FunctionName">Object.OwnerObject.owned_by</SPAN></A>(<SPAN CLASS="Argument">self</SPAN>)<SPAN CLASS="OneLiner"> # returns the name of the parent attribute</SPAN>
    <A CLASS="DocLink" HREF="#Object.OwnerObject.remove_other_references"><SPAN CLASS="PyKeyword">def</SPAN> <SPAN CLASS="FunctionName">Object.OwnerObject.remove_other_references</SPAN></A>(<SPAN CLASS="Argument">self</SPAN>)

    <SPAN CLASS="InheritsHead"># Inherited from Object.Object</SPAN>
    <SPAN CLASS="PyKeyword">def</SPAN> <SPAN CLASS="FunctionName">Object.Object.__init__</SPAN>(<SPAN CLASS="Argument">self</SPAN>, <SPAN CLASS="Argument">**args_super</SPAN>)
    <A CLASS="DocLink" HREF="#Object.Object.decl_attrs"><SPAN CLASS="PyKeyword">def</SPAN> <SPAN CLASS="FunctionName">Object.Object.decl_attrs</SPAN></A>(<SPAN CLASS="Argument">self</SPAN>, <SPAN CLASS="Argument">attrs</SPAN>)<SPAN CLASS="OneLiner"> # Define new attributes for <EM>self</EM></SPAN>
    <A CLASS="DocLink" HREF="#Object.Object.deep_construct"><SPAN CLASS="PyKeyword">def</SPAN> <SPAN CLASS="FunctionName">Object.Object.deep_construct</SPAN></A>(<SPAN CLASS="Argument">self</SPAN>, <SPAN CLASS="Argument">this_class</SPAN>, <SPAN CLASS="Argument">attrs_this_class</SPAN>, <SPAN CLASS="Argument">args_super</SPAN>, <SPAN CLASS="Argument">new_default={}</SPAN>, <SPAN CLASS="Argument">enforce_value={}</SPAN>, <SPAN CLASS="Argument">exclude_bases={}</SPAN>)<SPAN CLASS="OneLiner"> # Build an instance of a class.</SPAN>
    <A CLASS="DocLink" HREF="#Object.Object.init_attrs"><SPAN CLASS="PyKeyword">def</SPAN> <SPAN CLASS="FunctionName">Object.Object.init_attrs</SPAN></A>(<SPAN CLASS="Argument">self</SPAN>, <SPAN CLASS="Argument">attrs</SPAN>)<SPAN CLASS="OneLiner"> # Initialises existing attributes</SPAN>
    <A CLASS="DocLink" HREF="#Object.Object.possibly_init_attrs"><SPAN CLASS="PyKeyword">def</SPAN> <SPAN CLASS="FunctionName">Object.Object.possibly_init_attrs</SPAN></A>(<SPAN CLASS="Argument">self</SPAN>, <SPAN CLASS="Argument">attrs</SPAN>)

    <SPAN CLASS="InheritsHead"># Inherited from sb_services.SB_Service</SPAN>
    <SPAN CLASS="PyKeyword">def</SPAN> <SPAN CLASS="FunctionName">sb_services.SB_Service.__init__</SPAN>(<SPAN CLASS="Argument">self</SPAN>, <SPAN CLASS="Argument">buff</SPAN>, <SPAN CLASS="Argument">**args_super</SPAN>)

</PRE><H2>Description</H2><P>
Provides services for saving and restoring the contents of a
buffer and comparing them with the current state.</P>
<P>
<STRONG>INSTANCE ATTRIBUTES</STRONG></P>
<P>
*none*-- </P>
<P>
CLASS ATTRIBUTES**</P>

<DL>

<DT>
<EM>none</EM>
<DD>
</DL>
<H2 ID="sb_services.SB_ServiceState._state_cookie_class" CLASS="Method">sb_services.SB_ServiceState._state_cookie_class(<SPAN CLASS="Argument">self</SPAN>)</H2>
<P>None</P>

<P>
returns the class object for the type of cookie used by
store_current_state.</P>
<P>
<STRONG>INPUTS</STRONG></P>
<P>
<EM>none</EM></P>
<P>
<STRONG>OUTPUTS</STRONG></P>

<DL>

<DT>
<EM>CLASS</EM>
<DD>class of state cookies corresponding to this
SB_ServiceState
</DL>
<H2 ID="sb_services.SB_ServiceState.compare_selection_with_current" CLASS="Method">sb_services.SB_ServiceState.compare_selection_with_current(<SPAN CLASS="Argument">self</SPAN>, <SPAN CLASS="Argument">cookie</SPAN>)</H2>
<P>None</P>

<P>
compares the current buffer position and selection to these
values at the time when the cookie was returned by 
store_current_state.  If the state corresponding to the cookie has
been lost, compare_with_current will return false.</P>
<P>
<STRONG>INPUTS</STRONG></P>

<DL>

<DT>
<EM>SourceBuffCookie cookie</EM>
<DD>see store_current_state.  Note that
SourceBuffCookie is a dummy type, not an actual class.  The
actual type will vary with SourceBuff subclass.
</DL>
<P>
<STRONG>OUTPUTS</STRONG></P>

<DL>

<DT>
<EM>BOOL</EM>
<DD>true if position and selection are the same, false if 
they are not, or if it cannot be determined due to 
expiration of the cookie

</DL>
<H2 ID="sb_services.SB_ServiceState.compare_state_selections" CLASS="Method">sb_services.SB_ServiceState.compare_state_selections(<SPAN CLASS="Argument">self</SPAN>, <SPAN CLASS="Argument">first_cookie</SPAN>, <SPAN CLASS="Argument">second_cookie</SPAN>)</H2>
<P>None</P>

<P>
compares the selection and cursor positions at the times when
two cookies were returned by store_current_state.
If the state corresponding to either cookie has
been lost, compare_states will return false.</P>
<P>
This method does not synchronize with the editor prior to
comparing with "current".  To ensure that the "current" state 
is really current, the caller must synchronize.
(This avoids having duplicate synchronize calls 
when comparing with the current state of more than one buffer).</P>
<P>
<STRONG>INPUTS</STRONG></P>

<DL>

<DT>
<EM>SourceBuffCookie</EM> first_cookie, second_cookie
<DD>see 
store_current_state.  Note that SourceBuffCookie is a dummy 
type, not an actual class.  The actual type will vary with 
SourceBuff subclass.
</DL>
<P>
<STRONG>OUTPUTS</STRONG></P>

<DL>

<DT>
<EM>BOOL</EM>
<DD>true if position and selection are the same, false if 
they are not, or it cannot be determined due to expiration of 
either cookie

</DL>
<H2 ID="sb_services.SB_ServiceState.compare_states" CLASS="Method">sb_services.SB_ServiceState.compare_states(<SPAN CLASS="Argument">self</SPAN>, <SPAN CLASS="Argument">first_cookie</SPAN>, <SPAN CLASS="Argument">second_cookie</SPAN>, <SPAN CLASS="Argument">selection=0</SPAN>)</H2>
<P>None</P>

<P>
compares the buffer states at the times when
two cookies were returned by store_current_state.  By default,
only the buffer contents are compared, not the selection, unless
selection == 1.  If the state corresponding to either cookie has
been lost, compare_states will return false.</P>
<P>
<STRONG>INPUTS</STRONG></P>

<DL>

<DT>
<EM>SourceBuffCookie</EM> first_cookie, second_cookie
<DD>see 
store_current_state.  Note that SourceBuffCookie is a dummy 
type, not an actual class.  The actual type will vary with 
SourceBuff subclass.
<DT>
<EM>BOOL</EM> selection
<DD>compare selection as well as contents
</DL>
<P>
<STRONG>OUTPUTS</STRONG></P>

<DL>

<DT>
<EM>BOOL</EM>
<DD>true if states are the same, false if they are not, or
it cannot be determined due to expiration of either cookie

</DL>
<H2 ID="sb_services.SB_ServiceState.compare_with_current" CLASS="Method">sb_services.SB_ServiceState.compare_with_current(<SPAN CLASS="Argument">self</SPAN>, <SPAN CLASS="Argument">cookie</SPAN>, <SPAN CLASS="Argument">selection=0</SPAN>)</H2>
<P>None</P>

<P>
compares the current buffer state to its state at the time when
the cookie was returned by store_current_state.  By default,
only the buffer contents are compared, not the selection, unless
selection == 1.  If the state corresponding to the cookie has
been lost, compare_with_current will return false.</P>
<P>
<STRONG>INPUTS</STRONG></P>

<DL>

<DT>
<EM>SourceBuffCookie cookie</EM>
<DD>see store_current_state.  Note that
SourceBuffCookie is a dummy type, not an actual class.  The
actual type will vary with SB_ServiceState subclass.
<DT>
<EM>BOOL</EM> selection
<DD>compare selection as well as contents
</DL>
<P>
<STRONG>OUTPUTS</STRONG></P>

<DL>

<DT>
<EM>BOOL</EM>
<DD>true if state is the same, false if it is not, or
it cannot be determined due to expiration of the cookie

</DL>
<H2 ID="sb_services.SB_ServiceState.get_state_pos_selection" CLASS="Method">sb_services.SB_ServiceState.get_state_pos_selection(<SPAN CLASS="Argument">self</SPAN>, <SPAN CLASS="Argument">cookie</SPAN>)</H2>
<P>None</P>

<P>
retrieves the position and selection from a given state
cookie.  </P>
<P>
<STRONG>INPUTS</STRONG></P>

<DL>

<DT>
<EM>SourceBuffCookie cookie</EM>
<DD>see store_current_state.  Note that
SourceBuffCookie is a dummy type, not an actual class.  The
actual type will vary with SourceBuff subclass.
</DL>
<P>
<STRONG>OUTPUTS</STRONG></P>

<DL>

<DT>
<EM>(INT, (INT, INT))</EM>
<DD>position and selection at the time the
cookie was created by store_current_state, or None if the cookie
is invalid (usually because the state corresponding to the cookie 
has been lost).

</DL>
<H2 ID="sb_services.SB_ServiceState.restore_state" CLASS="Method">sb_services.SB_ServiceState.restore_state(<SPAN CLASS="Argument">self</SPAN>, <SPAN CLASS="Argument">cookie</SPAN>)</H2>
<P>None</P>

<P>
restores the buffer to its state at the time when
the cookie was returned by store_current_state.  Both the
contents and the selection will be restored.  However, other
data, such as the search history, may not.  The restore
operation can fail, which will be indicated by a return value of
0, so the caller should always check the return value.</P>
<P>
<STRONG>INPUTS</STRONG></P>

<DL>

<DT>
<EM>SourceBuffCookie cookie</EM>
<DD>see above.  Note that
SourceBuffCookie is a dummy type, not an actual class.  The
actual type will vary with SB_ServiceState subclass.
</DL>
<P>
<STRONG>OUTPUTS</STRONG></P>

<DL>

<DT>
<EM>BOOL</EM>
<DD>true if restore was successful
</DL>
<H2 ID="sb_services.SB_ServiceState.store_current_state" CLASS="Method">sb_services.SB_ServiceState.store_current_state(<SPAN CLASS="Argument">self</SPAN>)</H2>
<P>None</P>

<P>
stores the current state of the buffer, including both the
contents and the current selection, for subsequent restoration.
Store_current_state returns a "cookie" which can be passed to
restore_state or compare_with_current.  The type and attributes
of the cookie will depend on the specific subclass of
SB_ServiceState.  In the most straightforward implementation, it 
may include a copy of the entire contents of the
buffer and the selection.  In other cases, particularly when the
editor or SB_ServiceState provides an internal undo stack, it may simply be a
reference to a point in this stack.</P>
<P>
Important Notes:</P>
<P>
You should only pass the cookie to methods of
the SAME SourceBuff object from which it came.  Generally,
cookies can not be pickled and retrieved.</P>
<P>
The type of cookie will vary with the concrete subclass 
of SB_ServiceState.  The corresponding class object is 
returned by _state_cookie_class.  However, external callers
should not depend on the type, attributes, or methods 
of the cookie.</P>
<P>
<STRONG>INPUTS</STRONG></P>
<P>
<EM>none</EM></P>
<P>
<STRONG>OUTPUTS</STRONG></P>

<DL>

<DT>
<EM>SourceBuffCookie</EM>
<DD>state cookie (see above).  Note that
SourceBuffCookie is a dummy class.  The
actual return type will vary with SB_ServiceState subclass.

</DL>
<H2 ID="sb_services.SB_ServiceState.valid_cookie" CLASS="Method">sb_services.SB_ServiceState.valid_cookie(<SPAN CLASS="Argument">self</SPAN>, <SPAN CLASS="Argument">cookie</SPAN>)</H2>
<P>None</P>

<P>
checks whether a state cookie is valid or expired.
If the state corresponding to the cookie has
been lost, valid_cookie will return false.</P>
<P>
<STRONG>INPUTS</STRONG></P>

<DL>

<DT>
<EM>SourceBuffCookie cookie</EM>
<DD>see store_current_state.  Note that
SourceBuffCookie is a dummy type, not an actual class.  The
actual type will vary with SB_ServiceState subclass.
</DL>
<P>
<STRONG>OUTPUTS</STRONG></P>

<DL>

<DT>
<EM>BOOL</EM>
<DD>true if cookie is valid (i.e. restore_state should be
able to work)

</DL>
<H2 ID="Object.OwnerObject._cleanup_object" CLASS="Method">Object.OwnerObject._cleanup_object(<SPAN CLASS="Argument">self</SPAN>, <SPAN CLASS="Argument">object</SPAN>)</H2>
<P>attempt to call cleanup on object</P>

<P>
<STRONG>INPUTS*</STRONG></P>

<DL>

<DT>
<EM>OwnerObject object</EM>
<DD>note: class of object is the expected
class, but _cleanup_object doesn't assume this is correct, nor
does it check whether the object is a subclass of
OwnerObject, only that it is a class instance and that it
has a cleanup attribute
</DL>
<P>
<STRONG>OUTPUTS</STRONG></P>

<DL>

<DT>
<EM>STR</EM>
<DD>reason for error (or None if no error).

</DL>
<H2 ID="Object.OwnerObject.add_grandparent" CLASS="Method">Object.OwnerObject.add_grandparent(<SPAN CLASS="Argument">self</SPAN>, <SPAN CLASS="Argument">grandparent</SPAN>)</H2>
<P>None</P>

<P>
specify the name of the attribute containing a reference to 
this object's grandparent (or great-grandparent, etc.)
(Actually, any other reference which needs to be del'ed but not
cleaned up)</P>
<P>
<STRONG>INPUTS</STRONG></P>

<DL>

<DT>
<EM>STR grandparent</EM>
<DD>names of owned attributes
</DL>
<P>
<STRONG>OUTPUTS</STRONG></P>
<P>
<EM>none</EM>
</P>
<H2 ID="Object.OwnerObject.add_owned" CLASS="Method">Object.OwnerObject.add_owned(<SPAN CLASS="Argument">self</SPAN>, <SPAN CLASS="Argument">owned</SPAN>)</H2>
<P>append a new attribute name to the list of owned objects</P>

<P>
<STRONG>INPUTS</STRONG></P>

<DL>

<DT>
<EM>STR owned</EM>
<DD>names of owned attributes
</DL>
<P>
<STRONG>OUTPUTS</STRONG></P>
<P>
<EM>none</EM>
</P>
<H2 ID="Object.OwnerObject.add_owned_list" CLASS="Method">Object.OwnerObject.add_owned_list(<SPAN CLASS="Argument">self</SPAN>, <SPAN CLASS="Argument">owned</SPAN>)</H2>
<P>append new attribute names to the list of owned objects</P>

<P>
<STRONG>INPUTS</STRONG></P>

<DL>

<DT>
<EM>[STR] owned</EM>
<DD>names of owned attributes
</DL>
<P>
<STRONG>OUTPUTS</STRONG></P>
<P>
<EM>none</EM>
</P>
<H2 ID="Object.OwnerObject.cleanup" CLASS="Method">Object.OwnerObject.cleanup(<SPAN CLASS="Argument">self</SPAN>)</H2>
<P>None</P>

<P>
method to cleanup circular references by cleaning up 
any children, and then removing the reference to the parent</P>
<P>
<STRONG>INPUTS</STRONG></P>
<P>
<EM>none</EM></P>
<P>
<STRONG>OUTPUTS</STRONG></P>
<P>
<EM>none</EM>
</P>
<H2 ID="Object.OwnerObject.name_parent" CLASS="Method">Object.OwnerObject.name_parent(<SPAN CLASS="Argument">self</SPAN>, <SPAN CLASS="Argument">parent=None</SPAN>)</H2>
<P>None</P>

<P>
specify the name of the attribute containing a reference to 
this object's parent.</P>
<P>
<STRONG>INPUTS</STRONG></P>

<DL>

<DT>
<EM>STR parent</EM>
<DD>name of the parent, or None if none
</DL>
<P>
<STRONG>OUTPUTS</STRONG></P>
<P>
<EM>none</EM>
</P>
<H2 ID="Object.OwnerObject.owned_by" CLASS="Method">Object.OwnerObject.owned_by(<SPAN CLASS="Argument">self</SPAN>)</H2>
<P>returns the name of the parent attribute</P>

<P>
<STRONG>INPUTS</STRONG></P>
<P>
<EM>none</EM></P>
<P>
<STRONG>OUTPUTS</STRONG></P>

<DL>

<DT>
<EM>STR</EM>
<DD>name of the parent, or None if none

</DL>
<H2 ID="Object.OwnerObject.remove_other_references" CLASS="Method">Object.OwnerObject.remove_other_references(<SPAN CLASS="Argument">self</SPAN>)</H2>
<P>None</P>

<P>
additional cleanup to ensure that this object's references to
its owned objects are the last remaining references</P>
<P>
<STRONG>NOTE:</STRONG> subclasses must call their parent class's 
remove_other_references method, after performing their own duties.
Also, a class inheriting from two OwnerObject classes MUST
define remove_other_references and call both subclasses'
versions</P>
<P>
<STRONG>INPUTS</STRONG></P>
<P>
<EM>none</EM></P>
<P>
<STRONG>OUTPUTS</STRONG></P>
<P>
<EM>none</EM>
</P>
<H2 ID="Object.Object.decl_attrs" CLASS="Method">Object.Object.decl_attrs(<SPAN CLASS="Argument">self</SPAN>, <SPAN CLASS="Argument">attrs</SPAN>)</H2>
<P>Define new attributes for <EM>self</EM></P>

<P>
Attributes are directly through self.__dict__, thus bypassing safe
__setattr__.</P>
<P>
<STRONG>INPUTS</STRONG></P>

<DL>

<DT>
<EM>{STR: ANY}</EM> attrs
<DD>dictionary with attribute name as the keys and
 initial values as the values.
</DL>
<P>
<STRONG>OUTPUTS</STRONG></P>

<DL>

<DT>
<EM>none</EM>
<DD>
</DL>
<H2 ID="Object.Object.deep_construct" CLASS="Method">Object.Object.deep_construct(<SPAN CLASS="Argument">self</SPAN>, <SPAN CLASS="Argument">this_class</SPAN>, <SPAN CLASS="Argument">attrs_this_class</SPAN>, <SPAN CLASS="Argument">args_super</SPAN>, <SPAN CLASS="Argument">new_default={}</SPAN>, <SPAN CLASS="Argument">enforce_value={}</SPAN>, <SPAN CLASS="Argument">exclude_bases={}</SPAN>)</H2>
<P>Build an instance of a class.</P>

<P>
Basically, this method:
- declares and initialise all attributes listed in <EM>attrs_this_class</EM>
- invokes the <EM>__init__</EM> of all superclasses (with the exclusion of those listed in *exclude_bases*), passing them arguments in <EM>args_super</EM></P>

<DL>

<DT>
<EM>CLASS</EM> this_class
<DD>Class that we want to build. This is a
 class object as opposed to the name of a class. Constructors
 of immediate superclasses of <EM>this_class</EM> are called
 automatically, except if they are listed in *{CLASS: 1}
 exclude_bases*.
<DT>
<EM>{STR: ANY}</EM> attrs_this_class
<DD>New attributes (and their
 values) defined by class <EM>this_class</EM>. The keys are the names
 of the attributes and the values are the values of the
 attributes (either default values or values passed to
 *this_class.__init__*). An attribute with the appropriate
 name will be declared automatically and initialsed to the
 value specified in <EM>attrs_this_class</EM>.
<DT>
<EM>{STR: ANY}</EM> args_super
<DD>Arguments received by
<EM>this_class.__init__</EM> but not recognised by it. These are
assumed to be arguments defined in the <EM>__init__</EM> of some
ancestor class and are just passed up the construction
chain. Keys of <EM>args_super</EM> correspond to the names of the
arguments and the values corresponds to the values received
for them by <EM>this_class.__init__</EM>
<DT>
<EM>{STR: ANY}</EM> new_default={}
<DD>Used to change the default
 value of an ancestor constructor argument. In other words, if
 <EM>this_class.__init__</EM> was called without specifying a value
 for an argument that's listed in <EM>new_default</EM>, the default
 value defined in <EM>new_default</EM> will be used instead of
 whatever default might be defined in the constructor
 of an ancestor class. However, if the constructor was called
 WITH a specific value for that argument, that specific value
 will be used instead of both the defaults defined in
 <EM>new_default</EM> and the constructor of ancestor classes. Keys
 of <EM>new_default</EM> correspond to argument names, and values
 correspond to the new default values. If you don't specify a
 value of <EM>new_default</EM>, it defaults to <EM>{}</EM>, which means that
 the defaults of none of the ancestor constructor arguments
 are redefined by <EM>this_class</EM>.
<DT>
<EM>{STR: ANY}</EM> enforce_value={}
<DD>Lists of arguments with
 enforced values. If the constructor is called with a value
 for an argument that is different from the value specified
 for it in <EM>enforce_value</EM>, then an <A HREF="Object.EnforcedConstrArg.html">EnforcedConstrArg</A>
 exception will be raised. Also, if the constructor is called
 without specifying a value for a particular argument, then
 the value defined in <EM>enforce_value</EM> (if it exists) will be
 used instead of whatever default might be defined in an
 ancestor class. Keys of <EM>enforce_value</EM> correspond to
 argument names and values correspond to the enforced
 values. If you don't specify a value for <EM>enforce_value</EM>, it
 defaults to <EM>{}</EM>, which means that <EM>this_class.__init__</EM> does
 not enforce the value of any argument.
<DT>
<EM>{CLASS: BOOL}</EM> exclude_bases
<DD>Immediate base classes whose
constructors should not be called automatically. If an
immediate superclass of <EM>this_class</EM> is listed in
<EM>exclude_bases</EM>, then we don't automatically call its
constructor. It is assumed that the programmer will call the
constructor manually in <EM>this_class.__init__</EM>. If you do not
specify a value for <EM>exclude_bases</EM>, it will default to <EM>{}</EM>,
which means that the constructor of all immediate super
classes will be called automatically.
</DL>
<H2 ID="Object.Object.init_attrs" CLASS="Method">Object.Object.init_attrs(<SPAN CLASS="Argument">self</SPAN>, <SPAN CLASS="Argument">attrs</SPAN>)</H2>
<P>Initialises existing attributes</P>

<P>
Attributes are only set if they already exist in
 <EM>self.__dict__</EM>. Otherwise, an <EM>AttributeError</EM> exception is
 raised (provided PY_DEBUG_OBJECT=1).</P>
<P>
<STRONG>INPUTS</STRONG></P>

<DL>

<DT>
<EM>{STR: ANY}</EM> attrs
<DD>dictionary with attribute name as the keys and
 default values as the values.
</DL>
<P>
<STRONG>OUTPUTS</STRONG></P>

<DL>

<DT>
<EM>none</EM>
<DD>
</DL>
<H2 ID="Object.Object.possibly_init_attrs" CLASS="Method">Object.Object.possibly_init_attrs(<SPAN CLASS="Argument">self</SPAN>, <SPAN CLASS="Argument">attrs</SPAN>)</H2>
<P>None</P>

<P>
Initialises existing attributes, unless those attributes
already exist</P>
<P>
<STRONG>INPUTS</STRONG></P>

<DL>

<DT>
<EM>{STR: ANY}</EM> attrs
<DD>dictionary with attribute name as the keys and
 default values as the values.
</DL>
<P>
<STRONG>OUTPUTS</STRONG></P>

<DL>

<DT>
<EM>none</EM>
<DD>
</DL>

<HR>
<TABLE ALIGN="LEFT">
<TR><TD>
  <A HREF="http://validator.w3.org/check/referer" TARGET="validate">
    <IMG BORDER=0 SRC="http://validator.w3.org/images/vh40.gif"
     ALT="Valid HTML 4.0!" HEIGHT=31 WIDTH=88></A>
  <A HREF="http://www.w3.org/Style/CSS/Buttons">
    <IMG ALT="Made with CSS" BORDER=0 WIDTH=88 HEIGHT=31 
     SRC="http://www.w3.org/Style/CSS/Buttons/mwcos"></A>

</TD>
<TD STYLE="padding-left: 10">
  <SPAN CLASS="AUTHOR"></SPAN><BR>
  <SPAN CLASS="VERSION"></SPAN>
</TD>
</TABLE>

</body>
</html>
