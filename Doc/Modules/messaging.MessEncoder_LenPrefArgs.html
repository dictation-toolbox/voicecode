<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.0 Transitional//EN" "http://www.w3.org/TR/REC-html40/loose.dtd">
<html>

<head>

<META NAME="GENERATOR" CONTENT="pythondoc 0.7 (Thu Dec 26 23:44:31 2002)">

<link rel="stylesheet" href="pythondoc.css" type="text/css">

<title>Class MessEncoder_LenPrefArgs</title>
</head>

<body>
<P><A HREF="index.html">Table of contents</A> <A HREF="indices.html">Index</A></P>


<H1 CLASS="ClassName">class MessEncoder_LenPrefArgs - Encoding scheme for messages with length prefixed argument values.</H1>
<P CLASS="DeclaredIn">Declared in module <A HREF="messaging.html">messaging</A></P>

<H2 CLASS="ClassHierarchy">Inheritance hierarchy:</H2><P CLASS="ClassHierarchy">messaging.MessEncoder_LenPrefArgs<BR>
&nbsp;&nbsp;Object.Object<BR>
</P>

<H2>Synopsis</H2>
<PRE CLASS="ClassDeclaration">
<SPAN CLASS="PyKeyword">class</SPAN> <SPAN CLASS="ClassName">MessEncoder_LenPrefArgs</SPAN>(<A CLASS="DocLink" HREF="Object.Object.html">Object</A>):
    <SPAN CLASS="PyKeyword">def</SPAN> <SPAN CLASS="FunctionName">messaging.MessEncoder_LenPrefArgs.__init__</SPAN>(<SPAN CLASS="Argument">self</SPAN>, <SPAN CLASS="Argument">**args_super</SPAN>)
    <A CLASS="DocLink" HREF="#messaging.MessEncoder_LenPrefArgs.decode"><SPAN CLASS="PyKeyword">def</SPAN> <SPAN CLASS="FunctionName">messaging.MessEncoder_LenPrefArgs.decode</SPAN></A>(<SPAN CLASS="Argument">self</SPAN>, <SPAN CLASS="Argument">str_mess</SPAN>)<SPAN CLASS="OneLiner"> # Decodes a message with lenght prefixed argument values.</SPAN>
    <A CLASS="DocLink" HREF="#messaging.MessEncoder_LenPrefArgs.decode_data_item"><SPAN CLASS="PyKeyword">def</SPAN> <SPAN CLASS="FunctionName">messaging.MessEncoder_LenPrefArgs.decode_data_item</SPAN></A>(<SPAN CLASS="Argument">self</SPAN>, <SPAN CLASS="Argument">str_item</SPAN>)<SPAN CLASS="OneLiner"> # Decodes the head of a raw string to a data item.</SPAN>
    <A CLASS="DocLink" HREF="#messaging.MessEncoder_LenPrefArgs.decode_dict_descr"><SPAN CLASS="PyKeyword">def</SPAN> <SPAN CLASS="FunctionName">messaging.MessEncoder_LenPrefArgs.decode_dict_descr</SPAN></A>(<SPAN CLASS="Argument">self</SPAN>, <SPAN CLASS="Argument">descr</SPAN>)<SPAN CLASS="OneLiner"> # Parses the description of a dict item.</SPAN>
    <A CLASS="DocLink" HREF="#messaging.MessEncoder_LenPrefArgs.decode_list_descr"><SPAN CLASS="PyKeyword">def</SPAN> <SPAN CLASS="FunctionName">messaging.MessEncoder_LenPrefArgs.decode_list_descr</SPAN></A>(<SPAN CLASS="Argument">self</SPAN>, <SPAN CLASS="Argument">descr</SPAN>)<SPAN CLASS="OneLiner"> # Parses the description of a string item.</SPAN>
    <A CLASS="DocLink" HREF="#messaging.MessEncoder_LenPrefArgs.decode_string_descr"><SPAN CLASS="PyKeyword">def</SPAN> <SPAN CLASS="FunctionName">messaging.MessEncoder_LenPrefArgs.decode_string_descr</SPAN></A>(<SPAN CLASS="Argument">self</SPAN>, <SPAN CLASS="Argument">descr</SPAN>)<SPAN CLASS="OneLiner"> # Parses the description of a string item.</SPAN>
    <A CLASS="DocLink" HREF="#messaging.MessEncoder_LenPrefArgs.encode"><SPAN CLASS="PyKeyword">def</SPAN> <SPAN CLASS="FunctionName">messaging.MessEncoder_LenPrefArgs.encode</SPAN></A>(<SPAN CLASS="Argument">self</SPAN>, <SPAN CLASS="Argument">mess_name</SPAN>, <SPAN CLASS="Argument">mess_argvals</SPAN>)<SPAN CLASS="OneLiner"> # Encodes a message as a raw string, with length prefixed argument values.</SPAN>
    <A CLASS="DocLink" HREF="#messaging.MessEncoder_LenPrefArgs.encode_data_item"><SPAN CLASS="PyKeyword">def</SPAN> <SPAN CLASS="FunctionName">messaging.MessEncoder_LenPrefArgs.encode_data_item</SPAN></A>(<SPAN CLASS="Argument">self</SPAN>, <SPAN CLASS="Argument">item</SPAN>)

    <SPAN CLASS="InheritsHead"># Inherited from Object.Object</SPAN>
    <SPAN CLASS="PyKeyword">def</SPAN> <SPAN CLASS="FunctionName">Object.Object.__init__</SPAN>(<SPAN CLASS="Argument">self</SPAN>, <SPAN CLASS="Argument">**args_super</SPAN>)
    <A CLASS="DocLink" HREF="#Object.Object.decl_attrs"><SPAN CLASS="PyKeyword">def</SPAN> <SPAN CLASS="FunctionName">Object.Object.decl_attrs</SPAN></A>(<SPAN CLASS="Argument">self</SPAN>, <SPAN CLASS="Argument">attrs</SPAN>)<SPAN CLASS="OneLiner"> # Define new attributes for <EM>self</EM></SPAN>
    <A CLASS="DocLink" HREF="#Object.Object.deep_construct"><SPAN CLASS="PyKeyword">def</SPAN> <SPAN CLASS="FunctionName">Object.Object.deep_construct</SPAN></A>(<SPAN CLASS="Argument">self</SPAN>, <SPAN CLASS="Argument">this_class</SPAN>, <SPAN CLASS="Argument">attrs_this_class</SPAN>, <SPAN CLASS="Argument">args_super</SPAN>, <SPAN CLASS="Argument">new_default={}</SPAN>, <SPAN CLASS="Argument">enforce_value={}</SPAN>, <SPAN CLASS="Argument">exclude_bases={}</SPAN>)<SPAN CLASS="OneLiner"> # Build an instance of a class.</SPAN>
    <A CLASS="DocLink" HREF="#Object.Object.init_attrs"><SPAN CLASS="PyKeyword">def</SPAN> <SPAN CLASS="FunctionName">Object.Object.init_attrs</SPAN></A>(<SPAN CLASS="Argument">self</SPAN>, <SPAN CLASS="Argument">attrs</SPAN>)<SPAN CLASS="OneLiner"> # Initialises existing attributes</SPAN>
    <A CLASS="DocLink" HREF="#Object.Object.possibly_init_attrs"><SPAN CLASS="PyKeyword">def</SPAN> <SPAN CLASS="FunctionName">Object.Object.possibly_init_attrs</SPAN></A>(<SPAN CLASS="Argument">self</SPAN>, <SPAN CLASS="Argument">attrs</SPAN>)

</PRE><H2>Description</H2>
<H3>Used to go translates messages between the (name, {arg:val})
format and raw string format. The format for the message is:</H3>
   message ::= mess_name mess_content
<H3>where:</H3>

<DL>

<DT>
<EM>mess_content</EM>
<DD>Is a stringified description of the arguments
    of the messsage and their values. The names of the arguments are
    assumed to be strings, but their values can be string or more
    complex encodable types (see [MessEncoder] documentation for
    details on the encodable types).
</DL>

<H3>The format of <EM>mess_content</EM> can be described as:</H3>
   mess_content ::= dict_descr
   dict_descr := length <CODE>{</CODE> [key <CODE>=</CODE> value_descr <CODE>,']* '}</CODE>
   value_descr ::= (string_descr|list_descr|dict|descr)       
   string_descr ::= length <CODE>&lt;</CODE> string_content <CODE>&gt;</CODE>
   list_descr ::= length <CODE>[</CODE> [value_descr <CODE>,']* ']</CODE>
<H3>where:</H3>

<DL>

<DT>
<EM>length</EM>
<DD>the length of the string describing the content of
    a value (i.e. the part that's enclosed by &lt;&gt; (for string
    values), [] (for list values) or {} (for dict values).
<DT>
<EM>&lt;&gt;, [], {}</EM>
<DD>balanced expressions indicating whether a value
    is a string, list or dict type (also improve human readability
    which is useful for debugging).
<DT>
<EM>string_content</EM>
<DD>is just a string
</DL>

<H3>For example, the following string:</H3>
   <EM>set_selection 37{cursor_at=1&lt;1&gt;, range=11[2&lt;15&gt;, 1&lt;3&gt;]}</EM>
<H3>Corresponds to a <EM>set_selection</EM> message with following arguments:</H3>
    <EM>{'cursor_at': '1', 'range': ['15', '189']}</EM><STRONG>INSTANCE ATTRIBUTES</STRONG>*none*-- CLASS ATTRIBUTES**
<DL>

<DT>
<EM>none</EM>
<DD>
</DL>
..[MessEncoder] messaging.MessEncoder.html<H2 ID="messaging.MessEncoder_LenPrefArgs.decode" CLASS="Method">messaging.MessEncoder_LenPrefArgs.decode(<SPAN CLASS="Argument">self</SPAN>, <SPAN CLASS="Argument">str_mess</SPAN>)</H2>
<P>Decodes a message with lenght prefixed argument values.</P>

Decodes it to the format (name, {arg:val}).See <A HREF="messaging.MessEncoder_LenPrefArgs.html">MessEncoder_LenPrefArgs</A> for details of the encoded message. <STRONG>INPUTS</STRONG>
<DL>

<DT>
<EM>STR</EM> str_mess
<DD>The message in raw string format
</DL>
<STRONG>OUTPUTS</STRONG>
<DL>

<DT>
<EM>(STR, {STR: STR}) name_argvals</EM>
<DD>First element is the
message name, second element is message arguments in
<EM>(name, {arg:val})</EM> format.
</DL>
<H2 ID="messaging.MessEncoder_LenPrefArgs.decode_data_item" CLASS="Method">messaging.MessEncoder_LenPrefArgs.decode_data_item(<SPAN CLASS="Argument">self</SPAN>, <SPAN CLASS="Argument">str_item</SPAN>)</H2>
<P>Decodes the head of a raw string to a data item.</P>

See <A HREF="messaging.MessEncoder_LenPrefArgs.html">MessEncoder_LenPrefArgs</A> for details of the encoding of data items.<STRONG>INPUTS</STRONG>
<DL>

<DT>
<EM>STR str_item</EM>
<DD>The data item encoded as a string        
</DL>
<STRONG>OUTPUTS</STRONG>
<DL>

<DT>
(STR, ENCODABLE) (*rest_str, data_item*)
<DD><EM>rest_str</EM> is the
rest of <EM>str_item</EM> after the data item has been
parsed. <EM>data_item</EM> is the value of the data item (or
message).
</DL>
<H2 ID="messaging.MessEncoder_LenPrefArgs.decode_dict_descr" CLASS="Method">messaging.MessEncoder_LenPrefArgs.decode_dict_descr(<SPAN CLASS="Argument">self</SPAN>, <SPAN CLASS="Argument">descr</SPAN>)</H2>
<P>Parses the description of a dict item.</P>

See [MessEncoder_LenPrefArgs] for details of the encoding of
data items.  <STRONG>INPUTS</STRONG>
<DL>

<DT>
STR <EM>descr</EM>
<DD>The string description of the list
</DL>
<STRONG>OUTPUTS</STRONG>
<DL>

<DT>
(STR, {STR:ENCODABLE}) <EM>(descr, the_dict)</EM>
<DD>First entry is the The decoded dict item. Keys are strings
and values are encodable items.

</DL>
<H2 ID="messaging.MessEncoder_LenPrefArgs.decode_list_descr" CLASS="Method">messaging.MessEncoder_LenPrefArgs.decode_list_descr(<SPAN CLASS="Argument">self</SPAN>, <SPAN CLASS="Argument">descr</SPAN>)</H2>
<P>Parses the description of a string item.</P>

See [MessEncoder_LenPrefArgs] for details of the encoding of
data items.<STRONG>INPUTS</STRONG>
<DL>

<DT>
STR <EM>descr</EM>
<DD>The string description of the list
</DL>
<STRONG>OUTPUTS</STRONG>
<DL>

<DT>
[ENCODABLE] <EM>the_list</EM>
<DD>The decoded list of encodable values.
</DL>
..[MessEncoder_LenPrefArgs] messaging.MessEncoder_LenPrefArgs.html<H2 ID="messaging.MessEncoder_LenPrefArgs.decode_string_descr" CLASS="Method">messaging.MessEncoder_LenPrefArgs.decode_string_descr(<SPAN CLASS="Argument">self</SPAN>, <SPAN CLASS="Argument">descr</SPAN>)</H2>
<P>Parses the description of a string item.</P>

See [MessEncoder_LenPrefArgs] for details of the encoding of
data items.  <STRONG>INPUTS</STRONG>
<DL>

<DT>
STR <EM>descr</EM>
<DD>The string description of the list
</DL>
<STRONG>OUTPUTS</STRONG>
<DL>

<DT>
STR <EM>the_string</EM>
<DD>The decoded string value.
</DL>
..[MessEncoder_LenPrefArgs] messaging.MessEncoder_LenPrefArgs.html<H2 ID="messaging.MessEncoder_LenPrefArgs.encode" CLASS="Method">messaging.MessEncoder_LenPrefArgs.encode(<SPAN CLASS="Argument">self</SPAN>, <SPAN CLASS="Argument">mess_name</SPAN>, <SPAN CLASS="Argument">mess_argvals</SPAN>)</H2>
<P>Encodes a message as a raw string, with length prefixed argument values.</P>

See <A HREF="messaging.MessEncoder_LenPrefArgs.html">MessEncoder_LenPrefArgs</A> for details of the encoded message. 
<STRONG>INPUTS</STRONG>
<DL>

<DT>
STR <EM>mess_name</EM>
<DD>An identifier indicating what type of
message this is.
<DT>
{STR: STR} <EM>mess_argvals</EM>
<DD>Dictionnary describing the
 message in {argument:value} format
</DL>
<STRONG>OUTPUTS</STRONG>
<DL>

<DT>
<EM>STR str_mess</EM>
<DD>The message encoded as a string
</DL>
<H2 ID="messaging.MessEncoder_LenPrefArgs.encode_data_item" CLASS="Method">messaging.MessEncoder_LenPrefArgs.encode_data_item(<SPAN CLASS="Argument">self</SPAN>, <SPAN CLASS="Argument">item</SPAN>)</H2>
<P>None</P>

Encodes data item as a raw string, with length prefixed
argument values.See <A HREF="messaging.MessEncoder_LenPrefArgs.html">MessEncoder_LenPrefArgs</A> for details of the encoding of
data items.<STRONG>INPUTS</STRONG>
<DL>

<DT>
ENCODABLE <EM>item</EM>
<DD>Some encodable item (see <A HREF="messaging.MessEncoder.html">MessEncoder</A> for
details about encodable types).isinstance(value, types.intType)
</DL>
<STRONG>OUTPUTS</STRONG>
<DL>

<DT>
<EM>STR str_item</EM>
<DD>The data item encoded as a string
</DL>
<H2 ID="Object.Object.decl_attrs" CLASS="Method">Object.Object.decl_attrs(<SPAN CLASS="Argument">self</SPAN>, <SPAN CLASS="Argument">attrs</SPAN>)</H2>
<P>Define new attributes for <EM>self</EM></P>

Attributes are directly through self.__dict__, thus bypassing safe
__setattr__.<STRONG>INPUTS</STRONG>
<DL>

<DT>
<EM>{STR: ANY}</EM> attrs
<DD>dictionary with attribute name as the keys and
 initial values as the values.
</DL>
<STRONG>OUTPUTS</STRONG>
<DL>

<DT>
<EM>none</EM>
<DD>
</DL>
<H2 ID="Object.Object.deep_construct" CLASS="Method">Object.Object.deep_construct(<SPAN CLASS="Argument">self</SPAN>, <SPAN CLASS="Argument">this_class</SPAN>, <SPAN CLASS="Argument">attrs_this_class</SPAN>, <SPAN CLASS="Argument">args_super</SPAN>, <SPAN CLASS="Argument">new_default={}</SPAN>, <SPAN CLASS="Argument">enforce_value={}</SPAN>, <SPAN CLASS="Argument">exclude_bases={}</SPAN>)</H2>
<P>Build an instance of a class.</P>

Basically, this method:
- declares and initialise all attributes listed in <EM>attrs_this_class</EM>
- invokes the <EM>__init__</EM> of all superclasses (with the exclusion of those listed in *exclude_bases*), passing them arguments in <EM>args_super</EM>
<DL>

<DT>
<EM>CLASS</EM> this_class
<DD>Class that we want to build. This is a
 class object as opposed to the name of a class. Constructors
 of immediate superclasses of <EM>this_class</EM> are called
 automatically, except if they are listed in *{CLASS: 1}
 exclude_bases*.
<DT>
<EM>{STR: ANY}</EM> attrs_this_class
<DD>New attributes (and their
 values) defined by class <EM>this_class</EM>. The keys are the names
 of the attributes and the values are the values of the
 attributes (either default values or values passed to
 *this_class.__init__*). An attribute with the appropriate
 name will be declared automatically and initialsed to the
 value specified in <EM>attrs_this_class</EM>.
<DT>
<EM>{STR: ANY}</EM> args_super
<DD>Arguments received by
<EM>this_class.__init__</EM> but not recognised by it. These are
assumed to be arguments defined in the <EM>__init__</EM> of some
ancestor class and are just passed up the construction
chain. Keys of <EM>args_super</EM> correspond to the names of the
arguments and the values corresponds to the values received
for them by <EM>this_class.__init__</EM>
<DT>
<EM>{STR: ANY}</EM> new_default={}
<DD>Used to change the default
 value of an ancestor constructor argument. In other words, if
 <EM>this_class.__init__</EM> was called without specifying a value
 for an argument that's listed in <EM>new_default</EM>, the default
 value defined in <EM>new_default</EM> will be used instead of
 whatever default might be defined in the constructor
 of an ancestor class. However, if the constructor was called
 WITH a specific value for that argument, that specific value
 will be used instead of both the defaults defined in
 <EM>new_default</EM> and the constructor of ancestor classes. Keys
 of <EM>new_default</EM> correspond to argument names, and values
 correspond to the new default values. If you don't specify a
 value of <EM>new_default</EM>, it defaults to <EM>{}</EM>, which means that
 the defaults of none of the ancestor constructor arguments
 are redefined by <EM>this_class</EM>.
<DT>
<EM>{STR: ANY}</EM> enforce_value={}
<DD>Lists of arguments with
 enforced values. If the constructor is called with a value
 for an argument that is different from the value specified
 for it in <EM>enforce_value</EM>, then an <A HREF="Object.EnforcedConstrArg.html">EnforcedConstrArg</A>
 exception will be raised. Also, if the constructor is called
 without specifying a value for a particular argument, then
 the value defined in <EM>enforce_value</EM> (if it exists) will be
 used instead of whatever default might be defined in an
 ancestor class. Keys of <EM>enforce_value</EM> correspond to
 argument names and values correspond to the enforced
 values. If you don't specify a value for <EM>enforce_value</EM>, it
 defaults to <EM>{}</EM>, which means that <EM>this_class.__init__</EM> does
 not enforce the value of any argument.
<DT>
<EM>{CLASS: BOOL}</EM> exclude_bases
<DD>Immediate base classes whose
constructors should not be called automatically. If an
immediate superclass of <EM>this_class</EM> is listed in
<EM>exclude_bases</EM>, then we don't automatically call its
constructor. It is assumed that the programmer will call the
constructor manually in <EM>this_class.__init__</EM>. If you do not
specify a value for <EM>exclude_bases</EM>, it will default to <EM>{}</EM>,
which means that the constructor of all immediate super
classes will be called automatically.
</DL>
<H2 ID="Object.Object.init_attrs" CLASS="Method">Object.Object.init_attrs(<SPAN CLASS="Argument">self</SPAN>, <SPAN CLASS="Argument">attrs</SPAN>)</H2>
<P>Initialises existing attributes</P>

Attributes are only set if they already exist in
 <EM>self.__dict__</EM>. Otherwise, an <EM>AttributeError</EM> exception is
 raised (provided PY_DEBUG_OBJECT=1).<STRONG>INPUTS</STRONG>
<DL>

<DT>
<EM>{STR: ANY}</EM> attrs
<DD>dictionary with attribute name as the keys and
 default values as the values.
</DL>
<STRONG>OUTPUTS</STRONG>
<DL>

<DT>
<EM>none</EM>
<DD>
</DL>
<H2 ID="Object.Object.possibly_init_attrs" CLASS="Method">Object.Object.possibly_init_attrs(<SPAN CLASS="Argument">self</SPAN>, <SPAN CLASS="Argument">attrs</SPAN>)</H2>
<P>None</P>

Initialises existing attributes, unless those attributes
already exist<STRONG>INPUTS</STRONG>
<DL>

<DT>
<EM>{STR: ANY}</EM> attrs
<DD>dictionary with attribute name as the keys and
 default values as the values.
</DL>
<STRONG>OUTPUTS</STRONG>
<DL>

<DT>
<EM>none</EM>
<DD>
</DL>

<HR>
<TABLE ALIGN="LEFT">
<TR><TD>
  <A HREF="http://validator.w3.org/check/referer" TARGET="validate">
    <IMG BORDER=0 SRC="http://validator.w3.org/images/vh40.gif"
     ALT="Valid HTML 4.0!" HEIGHT=31 WIDTH=88></A>
  <A HREF="http://www.w3.org/Style/CSS/Buttons">
    <IMG ALT="Made with CSS" BORDER=0 WIDTH=88 HEIGHT=31 
     SRC="http://www.w3.org/Style/CSS/Buttons/mwcos"></A>

</TD>
<TD STYLE="padding-left: 10">
  <SPAN CLASS="AUTHOR"></SPAN><BR>
  <SPAN CLASS="VERSION"></SPAN>
</TD>
</TABLE>

</body>
</html>
