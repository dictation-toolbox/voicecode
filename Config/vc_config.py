##############################################################################
# VoiceCode, a programming-by-voice environment
#
# This program is free software; you can redistribute it and/or
# modify it under the terms of the GNU General Public License
# as published by the Free Software Foundation; either version 2
# of the License, or (at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with this program; if not, write to the Free Software
# Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA  02111-1307, USA.
#
# (C)2000, National Research Council of Canada
#
##############################################################################


##############################################################################
# 
# WARNING: DO NOT EDIT THIS FILE.
#
#          To configure VoiceCode, create a Config/user_config.py file
#          (you can start from one of the samples in Config/Samples)
#          and modify that user_config.py file instead.
#
##############################################################################

#
# Configuration script for VoiceCode
#

# Import configuration functions

from SymDict import define_language

# should this be here, or should the contents of these modules be added
# to the configuration namespace by NewMediatorObject?
from SpacingState import *
from config_helpers import *

import CmdInterp

from CSCmd import CSCmd
from CmdInterp import LSAlias, CapitalizationWord
from CmdInterp import LSAliasSet, CSCmdSet, CapitalizationWordSet
from LangDef import LangDef
from cont_gen import *
from cont_emacs import *
from actions_gen import *
from actions_emacs import *
from actions_C_Cpp import *
from actions_py import *
from actions_perl import *
import vc_globals

import KnownTargetModule

import sr_interface


###############################################################################
# Configure the grammar for toggling text mode on/off
###############################################################################

#
# Note: for off_spoken_as, we don't inlcude 'nat text off' 
#       because if the user sets off_sets_nat_text_to=1,
#       then nat text is not turned off when we exit text mode
#
text_mode_toggling(on_spoken_as=['text mode on', 'nat text on',
                                 'natural text on', 'code mode off', 'coding mode off'],
                   off_spoken_as=['text mode off', 'code mode on', 'coding mode on'],
                   off_sets_nat_text_to=1)

###############################################################################
# Associate file extensions to programming languages
###############################################################################

#
# Doesn't seem to work for now so we set it in SourceBuff.py directly
#
#  associate_language('c', 'C')
#  associate_language('h', 'C')
#  associate_language('py', 'python')

###############################################################################
# AppMgr and RecogStartMgr
###############################################################################


#  should the RecogStartMgr trust that the current
#  window corresponds to the editor when the editor first connects to
#  VoiceCode, or when it notifies VoiceCode of a new window.

# currently, do not trust to maintain compatibility with regression test
# results

trust_current_window(0)

# Known editor modules 

#     define modules
mod_Emacs = KnownTargetModule.DedicatedModule(module_name = 'EMACS',
        editor = 'emacs')
mod_exceed = \
    KnownTargetModule.DualModeDisplayByTitle(title_regex = '^Exceed$',
    module_name = 'EXCEED')

mod_ttssh = KnownTargetModule.RemoteShell(module_name = 'TTSSH')

mod_python = KnownTargetModule.LocalInterpreter(module_name = 'PYTHON',
    title_varies = 1)

mod_pythonw = KnownTargetModule.LocalInterpreter(module_name = 'PYTHONW',
    title_varies = 1)
  
#     add them to the RecogStartMgr
add_module(mod_Emacs)
add_module(mod_exceed)
add_module(mod_ttssh)
add_module(mod_python)
add_module(mod_pythonw)

# Known editors and the prefixes used to form their unique instance
# strings
add_prefix('emacs', 'Yak')
add_prefix('WaxEdit', 'Floor')
add_prefix('GenEdit', 'Inside')
add_prefix('EdSim', 'Standby')
add_prefix('dumbEdSim', 'Dumbo')

#############################################################################
# CSCs and LSAs that apply for ALL languages
#############################################################################

## Mediator Control

#
# These should probably be implemented as discrete commands, but
# I don't have the time to define a command grammar for them.
# -- AD
#
mediator_ctrl = CSCmdSet(name = 'mediator control',
    description = 'commands to control the mediator')
acmd = CSCmd(spoken_forms=['compile symbols'], 
             meanings={ContLanguage(None): ActionCompileSymbols()}, 
             docstring='compile symbols from active buffer.')
mediator_ctrl.add_csc(acmd)

acmd = CSCmd(spoken_forms=['show symbols', 'print symbols'], 
             meanings={ContLanguage(None): ActionPrintSymbols()}, 
             docstring='Print the list of all known symbols.')
mediator_ctrl.add_csc(acmd)

acmd = CSCmd(spoken_forms=['show abbreviations', 'print abbreviations'], 
             meanings={ContLanguage(None): ActionPrintAbbrevs()}, 
             docstring='Print the list of all known symbols.')
mediator_ctrl.add_csc(acmd)



#############################################################################
# Punctuation marks.
#############################################################################

# NOTE: DO NOT DELETE OR EDIT THE FOLLOWING STANDARD FORMS
#
# They are necessary to generate LSAs corresponding to the standard built-in
# punctuation words, without which CmdInterp will generate new symbols 
# from their spoken forms.  If you want to suppress a particular form, delete
# it from the speech-engine's vocabulary, and VoiceCode will
# automatically omit the corresponding LSA.  If you want to change the
# spacing of a standard form, simply add your own LSA with the same
# written and spoken form and VoiceCode will again automatically omit
# the corresponding standard form.  If you want to add a new form which
# has no built-in vocabulary entry, you must add it to the alternative
# punctuation objects (e.g. alt_US_punc).  

# If you are using a different speech engine which defines different
# standard forms, or a different language, check at the VoiceCode web
# site for alternative lists of standard forms, or go through the
# speech engine's vocabulary and create your own list (and please
# contribute it to VoiceCode for the benefit of other users).

# These are the standard forms for punctuation, as defined in the US English
# vocabulary of NaturallySpeaking 6.  They are used for
# the navigation-by-punctuation CSCs and to define corresponding LSAs
# for dictating punctuation.  

std_US_punc = \
    SinglePunctuation(name = 'standard punctuation (US English)')
    
# AD (206-04-22): For some reason I don't understand "{Backslash}\backslash"
# does not work but "{Backslash}\back slash" does. 
# 'backslash' as two words 'back slash'.
# std_US_punc.add('\\', ['backslash'], like_backslash)
std_US_punc.add('\\', ['backslash'], like_backslash)

std_US_punc.add('', ['New-Line', 'Next-Line'], hard_new_line)
std_US_punc.add('', ['New-Paragraph', 'Next-Paragraph'], 
    hard_paragraph)
std_US_punc.add('', ['space-bar'], hard_space)
std_US_punc.add('', ['tab-key'], hard_tab)
std_US_punc.add('!', ['exclamation-mark', 'exclamation-point'])
std_US_punc.add('#', ['number-sign', 'pound-sign'], 
    no_space_after)
std_US_punc.add('$', ['dollar-sign'], no_space_after)
std_US_punc.add('%', ['percent-sign'])
std_US_punc.add('&', ['ampersand', 'and-sign'], 
    no_space_after)
std_US_punc.add("'", ['apostrophe'], no_space_before | letters_and_digits)
std_US_punc.add("*", ['asterisk'])
std_US_punc.add("+", ['plus-sign'])
std_US_punc.add("-", ['minus-sign'])
std_US_punc.add("-", ['hyphen', 'numeric-hyphen'], 
    like_hyphen)
std_US_punc.add(",", ['comma'], like_comma)
std_US_punc.add(",", ['numeric-comma'], no_spaces)
std_US_punc.add("--", ['dash'])
std_US_punc.add(".", ['dot'], like_dot)
std_US_punc.add(".", ['period'], end_sentence)
std_US_punc.add(".", ['point'], like_point)
std_US_punc.add("...", ['ellipsis'], no_spaces)
std_US_punc.add("/", ['slash', 'forward-slash'], 
    like_slash)
std_US_punc.add(":", ['colon'], no_space_before)
std_US_punc.add(":", ['numeric-colon'], no_spaces)
std_US_punc.add(";", ['semicolon'], no_space_before)
std_US_punc.add("<", ['less-than'])
std_US_punc.add(">", ['greater-than'])
std_US_punc.add("=", ['equal-sign'])
std_US_punc.add('?', ['question-mark'], no_spaces)
std_US_punc.add('@', ['at-sign'], like_hyphen)
std_US_punc.add('^', ['caret'], no_spaces)
std_US_punc.add('_', ['underscore'], joins_identifier | no_space_after,
    new_symbol = 'start')
std_US_punc.add('|', ['vertical-bar'])
std_US_punc.add('~', ['tilde'], no_space_after)
std_US_punc.add('`', ['backquote'],
    no_space_after)
# this is a standard form, though open-/left-/right-/close- forms are
# not defined, so we need to add it as SinglePunctuation, not
# as PairedQuotes


alt_US_punc = \
    SinglePunctuation(name = 'alternative punctuation')
alt_US_punc.add('', ['blank space'], 
    spacing = hard_space)
alt_US_punc.add('*', ['star'], spacing = no_space_after)
# what is the correct spacing for this?  should it be different for
# different languages? (e.g. exponentiation vs. Python keyword
# arguments)
alt_US_punc.add('**', ['double star', 'double asterisk'],
    no_spaces)
alt_US_punc.add('|', ['pipe', 'pipe-sign'])
alt_US_punc.add('!', ['bang'], like_bang)
alt_US_punc.add('~', ['squiggle'], no_space_after)
alt_US_punc.add('::', ['double colon', 'colon colon'], 
    spacing = like_hyphen)

# shorter forms

# really, + and - should have binary_operator spacing, but that might
# mess up the regression tests, so I've left them as-is for now

alt_US_punc.add(" + ", ['plus'])
alt_US_punc.add(" - ", ['minus'])
alt_US_punc.add('%', ['percent'])
alt_US_punc.add('#', ['pound'], no_space_after)
alt_US_punc.add(";", ['semi'], no_space_before)





# Generic balanced expressions (e.g. "", '', (), [], {})
#
#       e.g. 'open paren' -> '(', 'close paren' -> ')'
#
#    We also define an LSA for typing an empty balanced expression and
#    putting the cursor after it.
#       e.g. 'empty parens' -> '()^'
#
#    We also define a CSC for typing an empty balanced expression and moving
#    the cursor in between.
#       e.g. 'between parens' -> '(^)'
#

std_US_grouping = \
    LeftRightPunctuation(name = 'standard grouping (US English)',
        singular_pair = ['%s pair'], 
        plural_pair = ['between %s', '%s pair', '%s'])
    
std_US_grouping.add('(',')', 
    ['paren'], ['parens'])
std_US_grouping.add('(',')', 
    ['parenthesis'])
# added separately so that if the user overrides paren, the singular
# LSAs for parenthesis are still added
std_US_grouping.add('[',']', 
    ['bracket'], ['brackets'])
std_US_grouping.add('{','}', 
    ['brace'], ['braces'])
std_US_grouping.add('<','>', 
    ['angle-bracket'], ['angle-brackets'])


std_US_quotes = \
    PairedQuotes(name = 'standard quotes (US English)',
        plural_pair = ['between %s', '%s'])

std_US_quotes.add('"', ['quote', 'quotes'], ['quotes'])
# begin-quotes and open-quotes are both standard forms for a 'single'
# double-quote symbol (")
std_US_quotes.add("'", ['single-quote'], ['single-quotes'])



# alternative forms
alt_US_grouping = \
    LeftRightPunctuation(name = 'alternate grouping',
        singular_pair = ['%s pair'], 
        plural_pair = ['between %s', '%s pair', '%s'])
    
alt_US_grouping.add('[',']', 
    ['square-bracket'], ['square-brackets'])
alt_US_grouping.add('{','}', 
    ['curly', 'curly-brace', 'curly-bracket'], 
    ['curlies', 'curly-braces', 'curly-brackets'])
alt_US_grouping.add('<','>', 
    ['angle'], ['angles'])


alt_US_quotes = \
    PairedQuotes(name = 'alternate quotes',
        plural_pair = ['between %s', '%s'])
alt_US_quotes.add('`', ['backquote', 'reverse-quote'], 
    ['backquotes', 'reverse-quotes'], no_singular_navigation = 1)
# oops - punctuation regression test tests empty backquotes (even though
# it is nonsense)
#alt_US_quotes.add('`', ['backquote', 'reverse-quote'], 
#   ['backquotes', 'reverse-quotes'], no_empty = 1)


######################################################################
# Sets to be filled in by user_config.py with help from config_helpers
######################################################################

#
# Letters using military pronunciation
#

military_letters = LSAliasSet(name = 'military letters',
    descriptions = 'letters using military pronunciation')

#
# Escaped characters (back slash a., a, alpha, etc.)
#

escaped_characters = CSCmdSet(name = 'escaped characters', 
    description = 'characters escaped with backslashes')

######################################################################
# Formatting commands
######################################################################

manual_formatting = CapitalizationWordSet(name = 'manual formatting',
    descriptions = 'commands for manual formatting within symbols')

word = CapitalizationWord(['Cap'], caps = 'cap')
manual_formatting.add_capitalization_word(word)

word = CapitalizationWord(['All-Caps'], caps = 'all-caps')
manual_formatting.add_capitalization_word(word)

word = CapitalizationWord(['No-Caps'], caps = 'no-caps')
manual_formatting.add_capitalization_word(word)

word = CapitalizationWord(['All-Caps On'], caps = 'all-caps', one_word = 0)
manual_formatting.add_capitalization_word(word)

word = CapitalizationWord(['Caps-On'], caps = 'cap', one_word = 0)
manual_formatting.add_capitalization_word(word)

word = CapitalizationWord(['No-Caps-On'], caps = 'no-caps', one_word = 0)
manual_formatting.add_capitalization_word(word)

word = CapitalizationWord(['All-Caps Off'], caps = 'normal', one_word = 0)
manual_formatting.add_capitalization_word(word)

word = CapitalizationWord(['No-Caps-Off'], caps = 'normal', one_word = 0)
manual_formatting.add_capitalization_word(word)

######################################################################
# Styling commands
######################################################################

manual_styling = CSCmdSet("manual symbol styling",
    description = "manually choose the style for the following symbol")

aCSC = CSCmd(spoken_forms = ['inter caps', 'cap Hungarian', 'Hungarian', 
                             'Hungarian notation'],
             meanings = {ContAny(): ActionStyling('std_intercaps')},
             docstring = 'Format the next symbol in InterCaps' + \
                 ' (a.k.a. Hungarian  notation)'
            )

manual_styling.add_csc(aCSC)

aCSC = CSCmd(spoken_forms = ['no-caps Hungarian', 'lower Hungarian'],
             meanings = {ContAny(): ActionStyling('std_lower_intercaps')},
             docstring = 'Format the next symbol in lowerHungarianNotation'
            )

manual_styling.add_csc(aCSC)

aCSC = CSCmd(spoken_forms = ['normal caps', 'join under'],
             meanings = {ContAny(): ActionStyling('std_underscores')},
             docstring = \
                 'Format the next symbol with words_joined_by_underscores'
            )

manual_styling.add_csc(aCSC)

aCSC = CSCmd(spoken_forms = ['all-caps style', 'all-caps join under'],
             meanings = {ContAny(): ActionStyling('std_all_caps_underscores')},
             docstring = \
                 'Format the next symbol with all caps ' + \
                 'WORDS_JOINED_BY_UNDERSCORES'
            )

manual_styling.add_csc(aCSC)

aCSC = CSCmd(spoken_forms = ['run together', 'no-space style'],
             meanings = {ContAny(): ActionStyling('std_run_together')},
             docstring = 'Format the next symbol with words runtogether'
            )

manual_styling.add_csc(aCSC)


######################################################################
# Jumping out of balanced expressions
######################################################################
#
# This really calls for some sort of grammar to automatically generate the
# spoken forms. But for now, exhaustively (or "exhaustingly" ;-) listing all
# possible spoken forms will have to do (although it's definitely exhausting"
#



out_of_balance = CSCmdSet("balanced expression navigation",
            description = """jumping out of any balanced expression""")

#
# All balanced expressions
#
acmd = CSCmd(spoken_forms=['jump out'],
             meanings={ContAny(): 
                ActionSearchBidirectionalRepeat(
                    regexp='[\]\)\}\'\"] {0,1}', direction = 1)},
             docstring='jump out of innermost balanced expression')
out_of_balance.add_csc(acmd)

acmd = CSCmd(spoken_forms=['back jump out', 'jump back out'],
             meanings={ContAny(): 
                ActionSearchBidirectionalRepeat(
                   regexp=' {0,1}[\[\(\{\'\"]',
                   direction=-1, where=-1)},
             docstring='jump backwards out of innermost balanced expression')
out_of_balance.add_csc(acmd)

#############################################################################
# Two digit numbers
#############################################################################

std_US_small_numbers = EnglishSmallNumbersSet()

#############################################################################
# Code indentation
#############################################################################
indent_cmds = CSCmdSet("indentation commands",
            description = """commands to manually adjust indentation""")

acmd = CSCmd(spoken_forms=['indent', 'tab', 'tab key'],
             meanings={ContAny(): ActionIncrIndentation(levels=1)})
indent_cmds.add_csc(acmd)
acmd = CSCmd(spoken_forms=['back indent', 'back tab'],
             meanings={ContAny(): ActionDecrIndentation(levels=1)})
indent_cmds.add_csc(acmd)
acmd = CSCmd(spoken_forms=['auto indent'],
             meanings={ContAny(): ActionAutoIndent()})
indent_cmds.add_csc(acmd)


#############################################################################
# Repeating last command
#############################################################################


#
# Note: "N times" doesn't do the same thing as utterance like "again N times"
# If "N times" is used immediatly after the command to be repeated
# (e.g. ['page down', '3 times']), then the command is repeated only N-1 times
# because we already executed it once. If it doesn't immediatly follow the
# command to be repeated (e.g.'4 times' in: ['page down', '3 times', '4 times])
# then it is repeated N times.
#
# Utterances like "again N times" on the other hand, always repeat the action
# N times.
#

repeat_last = CSCmdSet(name = 'repeat last command', 
    description = """Repeat last command.  
        Note: If "N times" is used immediatly after the command to be repeated
        (e.g. ['page down', '3 times']), then the command is repeated only N-1
        times because we already executed it once. If it doesn't immediatly
        follow the command to be repeated (e.g.'4 times' in: ['page down', '3
        times', '4 times]) then it is repeated N times.

        Utterances like "again N times" on the other hand, always repeat the
        action N times.
        """)


acmd = CSCmd(spoken_forms = \
                 ['again', 'do that again', 'repeat', 'repeat that', 'redo'],
             meanings={ContLastActionWas([ActionRepeatable]): \
                 ActionRepeatLastCmd(n_times=1)},
             docstring='Repeat last command')

# add extra forms for repeat 1 time which don't match the pattern
repeat_last.add_csc(acmd, name = 'repeat once')



#############################################################################
# Changing direction of last command
#############################################################################

change_direction = CSCmdSet(name = 'change direction of last command', 
    description = "Repeat last command (e.g. search) " + \
                  "in the opposite direction.")

acmd = CSCmd(spoken_forms=['reverse', 'reverse direction'],
             meanings={ContLastActionWas([ActionBidirectionalRepeat]): ActionRepeatBidirectCmd(n_times=1, direction=None)},
             docstring='Reverses the direction of previous command')
change_direction.add_csc(acmd)

acmd = CSCmd(spoken_forms=['backward', 'upward', 'leftward', 'previous one'],
             meanings={ContLastActionWas([ActionBidirectionalRepeat]): ActionRepeatBidirectCmd(n_times=1, direction=-1)},
             docstring='Repeats the previous command in backward/up/left direction.')
change_direction.add_csc(acmd)

acmd = CSCmd(spoken_forms=['forward', 'downward', 'rightward', 'next one'],
             meanings={ContLastActionWas([ActionBidirectionalRepeat]): ActionRepeatBidirectCmd(n_times=1, direction=1)},
             docstring='Repeats the previous command in forward/down/right direction.')
change_direction.add_csc(acmd)


#############################################################################
# Navigation within a buffer
#############################################################################

navigation_within_buffer = CSCmdSet(name = 'move up or down the page', 
                             description = "move up or down the page")

acmd = CSCmd(spoken_forms=['yo page down', 'page down'],
             meanings={ContAny(): ActionPaging(n_times=1, direction=1)},
             generate_discrete_cmd = 1,
             docstring='Move down a page')
navigation_within_buffer.add_csc(acmd)

acmd = CSCmd(spoken_forms=['yo page up', 'page up'],
             meanings={ContAny(): ActionPaging(n_times=1, direction=-1)},
             generate_discrete_cmd = 1,
             docstring='Move up a page')
navigation_within_buffer.add_csc(acmd)

acmd = CSCmd(spoken_forms=['yo beginning of line', 'go to beginning of line'],
                           meanings={ContAny(): ActionGotoBeginningOfLine()},
                           docstring='Move cursor to beginning of line.')
navigation_within_buffer.add_csc(acmd)

acmd = CSCmd(spoken_forms=['yo end of line', 'go to end of line'],
                           meanings={ContAny(): ActionGotoEndOfLine()},
                           docstring='Move cursor to end of line.')
navigation_within_buffer.add_csc(acmd)

acmd = CSCmd(spoken_forms=['yo top of file', 'yo top of buffer', 
                           'yo beginning of file', 'yo beginning of buffer',
                           'go to top of file', 'got to top of buffer', 
                           'go to beginning of file', 'got to beginning of buffer'],
                           meanings={ContAny(): ActionGotoTopOfBuffer()},
                           docstring='Move cursor to top of current file.')
navigation_within_buffer.add_csc(acmd)

acmd = CSCmd(spoken_forms=['yo bottom of file', 'yo bottom of buffer', 
                           'yo end of file', 'yo end of buffer'],
                           meanings={ContAny(): ActionGotoBottomOfBuffer()},
                           docstring='Move cursor to bottom of current file.')
navigation_within_buffer.add_csc(acmd)


#############################################################################
# Insertions and deletions
#############################################################################

#
# NOTE: Many of the commands in this section have same spoken form as some discrete 
#       NatSpeak commands. When that happens, set generate_discrete_cmd=1, otherwise
#       the NatSpeak command will take precedence over the VoiceCode command.
#       
#       But even that does not seem to work with all versions of Natspeak. So additionaly
#       create a variant whose spoken form starts with prefix "yo", so that users can
#       explicitly disambiguate between the NatSpeak and the VoiceCode command.
#       -- AD (2005-10-26)
#


#
# repeatable backspace commands (back space / delete backwards "" and 2 to 5
#

backspacing  = CSCmdSet(name = 'backspace multiple times',
    description = "backspace 1 to n times.")

insertion_deletions  = CSCmdSet(name = 'insert and deleting text',
                                descriptions = "commands for inserting and deleting text")
acmd = CSCmd(spoken_forms = ['delete that line'],
             meanings = {ContAny(): ActionDeleteCurrentLine()},
                         docstring = "delete line at cursor")
insertion_deletions.add_csc(acmd)

acmd = CSCmd(spoken_forms = ['delete that'],
             meanings = {ContTextIsSelected(): ActionDeleteSelectedText()},
             docstring = "copy selected text",
             generate_discrete_cmd=1)
insertion_deletions.add_csc(acmd)

acmd = CSCmd(spoken_forms = ['yo copy that', 'copy that'],
             meanings = {ContTextIsSelected(): ActionCopySelectedText()},
             docstring = "copy selected text",
             generate_discrete_cmd = 1)
insertion_deletions.add_csc(acmd)

acmd = CSCmd(spoken_forms = ['yo paste that', 'paste that'],
             meanings = {ContAny(): ActionPasteClipboard()},
             docstring = "paste text from the clipboard",
             generate_discrete_cmd=1)
insertion_deletions.add_csc(acmd)


acmd = CSCmd(spoken_forms = ['yo cut that', 'cut that'],
             meanings = {ContTextIsSelected(): ActionCutSelectedText()},
             docstring = "copy selected text",
             generate_discrete_cmd=1)
insertion_deletions.add_csc(acmd)

acmd = CSCmd(spoken_forms = ['yo copy line', 'copy line'],
             meanings = {ContAny(): ActionCopyLine()},
             docstring = "copy current line",
             generate_discrete_cmd=1)
insertion_deletions.add_csc(acmd)

acmd = CSCmd(spoken_forms = ['yo cut line', 'cut line'],
             meanings = {ContAny(): ActionCutLine()},
             docstring = "cut current line",
             generate_discrete_cmd=1)
insertion_deletions.add_csc(acmd)

##############################################################################
# CSCs and LSAs that apply for more than one language (but not necessarily
# all)
##############################################################################

## mathematical  operators

math_ops = LSAliasSet('mathematical operators', 
    description = "mathematical operators")

math_ops.add_lsa(LSAlias(['multiply by', 'multiplied by', 'times'], 
        {'C': ' * ', 'python': ' * ', 'perl': ' * '}, 
        spacing = binary_operator), name = 'multiplication')

math_ops.add_lsa(LSAlias(['to the power', 'to the power of', 'power of'], 
        {'python': '**', 'perl': '**'}, spacing = no_spaces), name =
        'exponentiation')
math_ops.add_lsa(LSAlias(['divide by', 'divided by'],
        {'C': ' / ', 'python': ' / ', 'perl': ' / '}, 
        spacing = binary_operator), name = 'division')

# These may shadow the alt_US_punc's "after plus" etc., unless has_lsa
# is language-specific.  Double check that and fix if it does

math_ops.add_lsa(LSAlias(['plus'], 
    {'C': ' + ', 'python': ' + ', 'perl': ' + '}, spacing = binary_operator), 
    name = 'addition')
math_ops.add_lsa(LSAlias(['minus'], 
    {'C': ' - ', 'python': ' - ', 'perl': ' - '}, spacing = binary_operator),
    name = 'subtraction')
math_ops.add_lsa(LSAlias(['plus plus','increment'], 
    {'C': '++', 'python': '++', 'perl': '++'}, spacing = unary_operator), 
    name = 'addition')
math_ops.add_lsa(LSAlias(['minus minus','decrement'], 
    {'C': '--', 'python': '--', 'perl': '--'}, spacing = unary_operator),
    name = 'subtraction')
math_ops.add_lsa(LSAlias(['modulo'], {'C': ' % ', 'python': ' % '}, 
    spacing = binary_operator))
math_ops.add_lsa(LSAlias(['left shift', 'shift left'], 
    {'C': ' << ', 'python': ' << ', 'perl': ' << '}, 
    spacing = binary_operator))
math_ops.add_lsa(LSAlias(['right shift', 'shift right'], 
    {'C': ' >> ', 'python': ' >> ', 'perl': ' >> '},
    spacing = binary_operator))

math_ops.add_lsa(LSAlias(['plus equals'], 
    {'C': ' += ', 'python': ' += ', 'perl': ' += '}, spacing = binary_operator),
    name = 'add and assign')
math_ops.add_lsa(LSAlias(['minus equals'], 
    {'C': ' -= ', 'python': ' -= ', 'perl': ' -= '}, spacing = binary_operator),
    name = 'subtract and assign')
math_ops.add_lsa(LSAlias(['times equals', 'star equals'], 
    {'C': ' *= ', 'python': ' *= ', 'perl': ' *= '}, spacing = binary_operator),
    name = 'multiply and assign')
math_ops.add_lsa(LSAlias(['slash equals', 'divide equals'], 
    {'C': ' /= ', 'python': ' /= ', 'perl': ' /= '}, spacing = binary_operator),
    name = 'divide and assign')

math_ops.add_lsa(LSAlias(['percent equals', 'modulo equals'], 
    {'C': ' %= ', 'python': ' %= ', 'perl': ' %= '}, spacing = binary_operator),
    name = 'assign remainder')
math_ops.add_lsa(LSAlias(['shift left equals', 'left shift equals'], 
    {'C': ' <<= ', 'python': ' <<= ', 'perl': ' <<= '}, 
    spacing = binary_operator),
    name = 'shift left and assign')
math_ops.add_lsa(LSAlias(['shift right equals', 'right shift equals'], 
    {'C': ' >>= ', 'python': ' >>= ', 'perl': ' >>= '}, 
    spacing = binary_operator),
    name = 'shift right and assign')

math_ops.add_lsa(LSAlias(['binary and', 'bitwise and'], {'C': ' & ', 'python': ' & '}, spacing = binary_operator))
math_ops.add_lsa(LSAlias(['binary or', 'bitwise or'], {'C': ' | ', 'python': ' | '}, spacing = binary_operator))
math_ops.add_lsa(LSAlias(['binary not', 'bitwise not'], {'C': '~', 'python': '~'}, spacing = unary_operator))
math_ops.add_lsa(LSAlias(['binary exclusive or', 'binary X. or', 'bitwise exclusive or', 'bitwise X. or'], {'C': ' ^ ', 'python': ' ^ '}, spacing = binary_operator))

math_ops.add_lsa(LSAlias(['ampersand equals', 'binary and equals', 
    'bitwise and equals'], 
    {'C': ' &= ', 'python': ' &= ', 'perl': ' &= '}, spacing = binary_operator),
    name = 'binary-and and assign')
math_ops.add_lsa(LSAlias(['pipe equals', 'binary or equals', 
    'bitwise and equals'], 
    {'C': ' |= ', 'python': ' |= ', 'perl': ' |= '}, spacing = binary_operator),
    name = 'binary-or and assign')
math_ops.add_lsa(LSAlias(['caret equals', 'exclusive or equals', 
    'binary exclusive or equals', 'binary X. or equals', 
    'bitwise exclusive or equals', 'bitwise X. or equals'], 
    {'C': ' ^= ', 'python': ' ^= ', 'perl': ' ^= '}, spacing = binary_operator),
    name = 'binary-exclusive-or and assign')

## logical operators

logic_ops = LSAliasSet('logical operators', 
    description = "logical operators")
logic_ops.add_lsa(LSAlias(['not'], {'python': 'not '}, ), 
    name = 'python logical not')
logic_ops.add_lsa(LSAlias(['not'], 
    {'C': '!', 'perl': '!'}, spacing = like_bang), name = 'logical not')

logic_ops.add_lsa(LSAlias(['or'], 
    {'python': ' or ', 'C': ' || ', 'perl': ' || '}))
logic_ops.add_lsa(LSAlias(['and'], 
    {'python': ' and ', 'C': ' && ', 'perl': ' && '}))

# comparison operators
comparisons = LSAliasSet('comparison operators', 
    description = "comparison operators")

comparisons.add_lsa(LSAlias(['equals', 'equal', 'is assigned', 'assign value'],
        {'C': ' = ', 'python': ' = '}, comparison_operator))
comparisons.add_lsa(LSAlias(['less than', 'is less than'],
        {'C': ' < ', 'python': ' < ', 'perl': ' < '},
        comparison_operator))
comparisons.add_lsa(LSAlias(['greater than', 'is greater than'],
        {'C': ' > ', 'python': ' > ', 'perl': ' > '},
        comparison_operator))
comparisons.add_lsa(LSAlias(['less or equal to', 'is less or equal to', 'less or equal',
        'is less or equal', 'less than or equal to'],
        {'C': ' <= ', 'python': ' <= ', 'perl': ' <= '},
        comparison_operator))
comparisons.add_lsa(LSAlias(['greater or equal to', 'is greater or equal to', 'greater or equal',
        'is greater or equal', 'greater than or equal to'],
        {'C': ' >= ', 'python': ' >= ', 'perl': ' >= '},
        comparison_operator))
comparisons.add_lsa(LSAlias(['not equal', 'is not equal', 'not equal to', 'is not equal to',
        'is different from', 'differs from', 'bang equal'],
        {'C': ' != ', 'python': ' != ', 'perl': ' != '},
        comparison_operator))
comparisons.add_lsa(LSAlias(['equal to', 'is equal to', 'is equal'],
        {'C': ' == ', 'python': ' == ', 'perl': ' == '},
        comparison_operator))


# functional names for empty pairs (as opposed to the literal names like
# empty parens defined by std_grouping)

empty_pairs = LSAliasSet('empty pairs', 
    description = 'functional names for empty pairs of punctuation symbols')

empty_pairs.add_lsa(LSAlias(['without arguments', 'with no arguments', 'without argument',
        'with no argument', 'empty function'],
        {'python': '()', 'perl': '()', 'C': '()'}, 
        spacing = joins_identifier))

empty_pairs.add_lsa(LSAlias(['empty list'], {'python': '[]', 'perl': '()'}))

empty_pairs.add_lsa(LSAlias(['empty dictionary', 'empty hash'], {'python': '{}', 'perl': '{}'}))

# functional names for commands inserting paired punctuation around the
# current cursor location (as opposed to the literal names like
# paren pair defined by std_grouping)

functional_pairs = CSCmdSet('functional pairs',
    description = 'functional names for paired punctuation')

acmd = CSCmd(spoken_forms=['with arguments', 'with argument', 'call with',
                           'called with', 'function of'],
             meanings={ContC(): gen_parens_pair, ContPy(): gen_parens_pair,
                       ContPerl(): gen_parens_pair},
             docstring='argument list for function')
functional_pairs.add_csc(acmd)        

acmd = CSCmd(spoken_forms=['dictionary with elements', 'hash with elements', 
                           'new dictionary', 'new hash',
                           'dictionary with items', 'hash with items'],
             meanings={ContPy(): ActionInsert('{', '}', 
                                     spacing = like_open_paren),
                       ContPerl(): ActionInsert('(', ')', 
                                     spacing = like_open_paren)},
             docstring='dictionary with enumerated elements')
functional_pairs.add_csc(acmd)             

acmd = CSCmd(spoken_forms=['list with elements', 'new list',
                           'list with items'],
             meanings={ContPy(): ActionInsert('[', ']',
                                     spacing = like_open_paren),
                       ContPerl(): ActionInsert('(', ')',
                                     spacing = like_open_paren)},
             docstring='list with enumerated elements')
functional_pairs.add_csc(acmd)
acmd = CSCmd(spoken_forms=['at index', 'indexed by'],
             meanings={ContPy(): ActionInsert('[', ']',
                                     spacing = like_open_paren),
                       ContC(): ActionInsert('[', ']',
                                     spacing = like_open_paren),
                       ContPerl(): ActionInsert('[', ']',
                                     spacing = like_open_paren)},
             docstring='array element access')
functional_pairs.add_csc(acmd)                          
acmd = CSCmd(spoken_forms=['sliced at'],
             meanings={ContPy(): ActionInsert('[', ']',
                                     spacing = like_open_paren)},
             docstring='array slicing')             
functional_pairs.add_csc(acmd)             
# Note: 'at key' is often misrecognised
acmd = CSCmd(spoken_forms=['with key', 'item with key', 'at key'],
             meanings={ContPy(): ActionInsert('[', ']',
                                     spacing = like_open_paren),
                       ContPerl(): ActionInsert('{', '}',
                                     spacing = like_open_paren)},
             docstring='dictionary/hash element access')
functional_pairs.add_csc(acmd)


# aliases for dictating comments

comment_aliases = LSAliasSet('comment aliases', 
    description = "aliases for dictating comments")
comment_commands = CSCmdSet('comment commands',
    description = "commands for dictating comments")

comment_aliases.add_lsa(LSAlias(['comment line', 'new comment', 'comment below', 'new comment below'], 
    {'perl': '\n#', 'python': '\n#', 'C': '\n//'}, spacing = no_space_before))            
acmd = CSCmd(spoken_forms=['comment above', 'add comment above', 
                           'new comment above', 'comment line above'], 
             meanings={ContLanguage('python'): ActionPyCommentAbove()}, 
             docstring='add a new comment line above current one.')
             
comment_commands.add_csc(acmd)              
comment_aliases.add_lsa(LSAlias(['begin comment'],
    {'perl': '# ', 'python': '# ', 'C': '// '}))
comment_aliases.add_lsa(LSAlias(['begin long comment'],
    {'C': '/* '}))
comment_aliases.add_lsa(LSAlias(['end long comment'],
    {'C': '*/'}))


# miscellaneous - should really have a better name for this set

misc_aliases = LSAliasSet('miscellaneous aliases', 
    description = 'miscellaneous commands')
misc_aliases.add_lsa(LSAlias(['print'], {'python': 'print ', 'perl': 'print '}))
misc_aliases.add_lsa(LSAlias(['return'], {'C': 'return ', 'python': 'return '}))
misc_aliases.add_lsa(LSAlias(['break'], {'python': 'break\n', 'C': 'break;\n'},
    spacing = no_space_after))
misc_aliases.add_lsa(LSAlias(['continue'], {'python': 'continue\n', 
    'C': 'continue;\n'}, spacing = no_space_after))


# new statement

new_statement = CSCmdSet('new statement', 
description = 'new statement commands') 

acmd = CSCmd(spoken_forms=['new statement', 'new statement below'],
             meanings={ContPy(): py_new_statement, ContC(): c_new_statement},
             docstring='start new statement on next line')
new_statement.add_csc(acmd)

acmd = CSCmd(spoken_forms=['new statement above'],
             meanings={ContPy(): py_new_statement_above,
                       ContC(): c_new_statement_above},
             docstring='start new statement on previous line')
new_statement.add_csc(acmd)


# compound statement dictation/navigation

compound_statements = CSCmdSet('compound statements', 
    description = 'commands for dictation and navigating compound statements') 

acmd = CSCmd(spoken_forms=['body', 'go to body'],
             meanings={ContC(): c_goto_body, ContPy(): py_goto_body,
                       ContPerl(): c_goto_body},
             docstring = 'move to body of a compound statement')
compound_statements.add_csc(acmd)


# control structures (conditionals and loops)

ctrl_structures = CSCmdSet('control structures', 
    description = 'commands for dictation and navigation of control structures')

acmd = CSCmd(spoken_forms=['for', 'for loop', 'for each'],
             meanings={ContC(): c_simple_for, 
                       ContBlankLine('python'): py_simple_for,
                       ContPerl(): c_simple_for},
             docstring='for loop')
ctrl_structures.add_csc(acmd)
acmd = CSCmd(spoken_forms=['while', 'while loop'],
             meanings={ContC(): c_simple_while,
#                       ContPy(): ActionInsert('while ', ':\n\t'),             
                       ContBlankLine('python'): ActionInsert('while ', ':\n\t'),
                       ContPerl(): c_simple_while},
             docstring='while loop')
ctrl_structures.add_csc(acmd)
acmd = CSCmd(spoken_forms=['do', 'do the following', 'loop body', 'for body',
                           'while body'],
             meanings={ContC(): c_goto_body, ContPy(): py_goto_body,
                       ContPerl(): c_goto_body},
             docstring = 'move to body of loop')
ctrl_structures.add_csc(acmd)
acmd = CSCmd(spoken_forms=['do while'],
             meanings={ContC(): c_do_while},
             docstring='do...while loop')
ctrl_structures.add_csc(acmd)
acmd = CSCmd(spoken_forms=['if', 'if statement'],
             meanings={ContBlankLine('python'): ActionInsert('if ', ':\n\t'),
                       ContC(): ActionInsert('if (', ')\n\t{\n\t\n}',
                           spacing = no_space_after),
                       ContPerl(): ActionInsert('if (', ') {\n\t}',
                           spacing = no_space_after)},
             docstring = 'if statement')
ctrl_structures.add_csc(acmd)
acmd = CSCmd(spoken_forms=['else if', 'else if clause', 
                           'elif', 'elif clause'],
             meanings={ContPy(): ActionInsertNewClause('($|\n)', 
                           code_bef = 'elif ', code_after = ': \n\t', 
#                           back_indent_by=0,
# I suspect the default value of back_indent_by = 1 won't hurt in the
# Emacs case, because elif will have the correct indentatation
# initially, and Emacs will be smart enough to leave it alone.  
# It is, except if something on the previous line (like a return
# statement) triggers a back indent
                           where = -1),
# Using where = -1 should solve the problem of the extra \n
# -- DCF
#                           code_bef = 'elif ', code_after = ': \n\t', where = -1),
                       ContC(): c_else_if,
                       ContPerl(): perl_else_if},
             docstring = 'else if clause of conditional statement')
ctrl_structures.add_csc(acmd)
acmd = CSCmd(spoken_forms=['else clause', 'else'],
             meanings={ContPy(): ActionInsertNewClause('($|\n)', 
                          code_bef = 'else:\n\t', code_after = '', where = -1),
# try where = -1 here as well 
                       ContC(): c_else,
                       ContPerl(): c_else},
             docstring = 'else clause of conditional statement')
ctrl_structures.add_csc(acmd)
acmd = CSCmd(spoken_forms=['then', 'then do', 'then do the following',
                           'if body'],
             meanings={ContPy(): py_goto_body, ContC(): c_goto_body,
                       ContPerl(): c_goto_body},
             docstring='move to body of a conditional')
ctrl_structures.add_csc(acmd)

# data structures (C struct, C++ and Python classes, etc.)

data_structures = CSCmdSet('data structures', 
    description = 'commands for dictation of commands to define new data types')

acmd = CSCmd(spoken_forms=['struct','structure','define structure','declare structure'],
             meanings={ContC(): ActionInsert('struct ','\r\t{\n\t\n};')},
                       docstring='structure definition')
data_structures.add_csc(acmd)
acmd = CSCmd(spoken_forms=['union','define union','declare union'],
             meanings={ContC(): ActionInsert('union ','\r\t{\n\t\n};')},
                       docstring='union definition')
data_structures.add_csc(acmd)

acmd = CSCmd(spoken_forms=['class', 'define class', 'declare class',
                           'class definition', 'class declaration',
                           'new class'],
             meanings={ContBlankLine('C'): cpp_class_definition,
                       ContBlankLine('python'): py_class_definition},
             docstring='class definition')
data_structures.add_csc(acmd)
acmd = CSCmd(spoken_forms=['sub class of', 'inherits from', 'is subclass',
                           'is subclass of', 'with superclass',
                           'with superclasses'],
             meanings={ContC(): cpp_subclass, ContPy(): py_subclass},
             docstring='superclasses of a class')
data_structures.add_csc(acmd)
acmd = CSCmd(spoken_forms=['class body'],
             meanings={ContC(): cpp_class_body, ContPy(): py_class_body},
             docstring='move to body of class definition')
data_structures.add_csc(acmd)

# function definitions

function_definitions = CSCmdSet('function definitions', 
    description = 'commands for defining new functions')

acmd = CSCmd(spoken_forms=['declare method', 'add method'],
             meanings={ContC(): c_function_declaration,
                       ContPy(): py_method_declaration},
             docstring='method definition')
function_definitions.add_csc(acmd)

# SN: separated 'definition' and 'declaration' commands to support C/C++

acmd = CSCmd(spoken_forms=['define function'],
             meanings={ContC(): c_function_definition,
                       ContPy(): py_function_declaration},
             docstring='function definition')
function_definitions.add_csc(acmd)

acmd = CSCmd(spoken_forms=['define method'],
             meanings={ContC(): c_function_definition,
                       ContPy(): py_method_declaration},
             docstring='function definition')
function_definitions.add_csc(acmd)

acmd = CSCmd(spoken_forms=['declare function'],
             meanings={ContC(): c_function_declaration,
                       ContPy(): py_function_declaration},
             docstring='function definition')
function_definitions.add_csc(acmd)

acmd = CSCmd(spoken_forms=['add argument', 'add arguments'],
             meanings={ContC(): c_function_add_argument,
                       ContPy(): py_function_add_argument},
             docstring='move to end of argument list of a function call or declaration')

function_definitions.add_csc(acmd)
acmd = CSCmd(spoken_forms=['function body', 'method body'],
             meanings={ContC(): c_function_body, ContPy(): py_function_body},
             docstring='move to body of a function definition')
function_definitions.add_csc(acmd)


###############################################################################
# Python specific stuff
###############################################################################

#
# Define the native syntax of Python
#
define_language('python',
                # Note: Have to be careful about the start of the symbol so
                #       it doesn't match:
                #           - strings that start with a number
                #           - strings that only contain _ and no alphanums like "__" 
                #             (not likely to appear in a python file, but the
                #             user could type it by mistake)
                #
                LangDef(regexp_symbol='([a-zA-Z]|_+[a-zA-Z])[a-zA-Z0-9_]*',
                        regexps_no_symbols=['#[^\n]*\n', '"""[\s\S]*?"""',
                                            '"([^"]|\\")*?"',

                                            '\'([^\']|\\\')*?\'']))
#
# CSCs and LSAs specific to Python
#

# misc Python aliases and CSCs

misc_python = LSAliasSet('miscellaneous Python fragments',
    description = "miscellaneous Python expressions and constructs")

misc_python_cmds = CSCmdSet('miscellaneous Python commands',
    description = "miscellaneous Python commands")

misc_python.add_lsa(LSAlias(['none'], {'python': 'None'}))
misc_python.add_lsa(LSAlias(['self dot'], {'python': 'self.'}, spacing =
    no_space_after))
    
#AD (2003-07-01) --
#  I created this LSA so that 'self' would not be printed
#  as __self__. This is a temporary fix. The right way to fix
#  this problem would be to implement a smarter algorithm for
#  choosing between homophonic symbols (e.g. chose most recent, 
#  choose one with closest occurence to the cursor, etc...)
#            

misc_python.add_lsa(LSAlias(['self'], {'python': 'self'}))
    
misc_python.add_lsa(LSAlias(['empty tuple'], {'python': '()'}))

misc_python.add_lsa(LSAlias(['format with'], {'python': ' % '}))

acmd = CSCmd(spoken_forms=['continue statement'],
             meanings={ContPy(): ActionInsert('\\\n', '', 
                                     spacing = no_space_after)},
             docstring='python continue statement on next line')

misc_python_cmds.add_csc(acmd)

acmd = CSCmd(spoken_forms=['define in it', 'define init', 'define constructor'],
             meanings={ContPy(): py_constructor_definition},
             docstring='constructor definition')

misc_python_cmds.add_csc(acmd)

# simple Python statements

python_statements = LSAliasSet('simple Python statements', 
    description = 'aliases for simple Python statements')

python_statements.add_lsa(LSAlias(['global', 'global variable', 'global variables'],
        {'python': 'global '}))

python_statements.add_lsa(LSAlias(['del', 'delete object',
         'delete instance', 'delete item'],
        {'python': 'del '}))

python_statements.add_lsa(LSAlias(['exec'], {'python': 'exec '}))
python_statements.add_lsa(LSAlias(['pass'], {'python': 'pass\n'}))


python_statements.add_lsa(LSAlias(['assert'], {'python': 'assert '}))

python_statements.add_lsa(LSAlias(['raise', 'raise exception'], {'python': 'raise '}))

# compound python statements

python_compound = CSCmdSet('Python compound statements',
    description = "commands for dictating Python-specific compound statements")

acmd = CSCmd(spoken_forms=['lambda'],
             meanings={ContPy(): ActionInsert('lambda ', ': ')},
             docstring='python lamdba function')
python_compound.add_csc(acmd)

acmd = CSCmd(spoken_forms=['try'],
             meanings={ContBlankLine('python'): ActionInsert('try:\n\t', '', 
                 spacing = no_space_after)},
             docstring='python try statement')
python_compound.add_csc(acmd)
acmd = CSCmd(spoken_forms=['except', 'except for', 'catch exceptions', 'except when', 'except clause'],
             meanings={ContPy(): ActionInsertNewClause('($|\n)', code_bef='except ', code_after=': \n\t')},
             docstring='python except statement')
python_compound.add_csc(acmd)
acmd = CSCmd(spoken_forms=['finally', 'finally do'],
             meanings={ContPy(): ActionInsertNewClause('($|\n)', code_bef='finally:\n\t')},
             docstring='finally clause of python try statement')
python_compound.add_csc(acmd)

# Python import statements

python_imports = LSAliasSet('Python import statements',
    description = "Python import module statements")
python_imports_cscs = CSCmdSet('Python import statements',
    description = "Python import module statements")

python_imports_cscs.add_csc(CSCmd(spoken_forms=['from', 'from module'], 
                            meanings={ContBlankLine('python'): ActionInsert('from ')}))
#
# Support two uses of the word import:
#    import module_name
#    from module_name import symbol_name
#
python_imports_cscs.add_csc(CSCmd(spoken_forms=['import'], 
                            meanings={ContBlankLine('python'): ActionInsert('import '), ContPy(): ActionInsert(' import ')}))                            
                            

# this form used for statements : import module1, module2, etc...
python_imports.add_lsa(LSAlias(['import module', 'import modules'], {'python': 'import '}))
# this form used for statements like: from module symbol1, symbol2, etc...
python_imports.add_lsa(LSAlias(['import symbols', 'import symbol'], {'python': ' import '}))
# this form used for statements like: from module import all
python_imports.add_lsa(LSAlias(['import all'], {'python': ' import *'}))

# Python-specific comparison operators

python_comparisons = LSAliasSet('Python comparison operators',
    description = "Python-specific comparison operators")
python_comparisons.add_lsa(LSAlias(['in list', 'in sequence', 'is in', 'is in list', 'is in sequence'], {'python': ' in '}))

# '<>' is obsolete in python ('!=' is now the encouraged form), but we include
# it so we can select code that uses the obsolete form
# UGH - this would shadow the new form for dictation - either one could
# be recognized
#add_lsa(LSAlias(['not equal', 'is not equal', 'not equal to', 'is not equal to',
#        'is different from', 'differs from', 'less greater',
#        'less than greater than'],
#        {'python': ' <> '}))

python_comparisons.add_lsa(LSAlias(['is same', 'same as', 'is same as'], {'python': ' is '}))


# Python-specific quotes

python_quotes = PairedQuotes(name = 'Python-specific quotes',
        plural_pair = ['between %s', '%s'], context = ContPy())
python_quotes.add('"""', ['triple-quote', 'triple-quotes'], ['triple-quotes'], 
    no_empty = 1)
python_quotes.add("'''", ['triple-single-quote', 'three-single-quote', 'three-single'], ['triple-single-quotes', 'three-single-quotes', 'three-singles'], 
    no_empty = 1)
python_quotes.create(interpreter, force = 1)

# Python-specific string variants

python_string_qualifiers = LSAliasSet('Python-specific string qualifiers',
   description = 'Qualifiers for Python-specific string types\n' +
                 '("r" for raw strings, "u" for Unicode strings)')

python_string_qualifiers.add_lsa(LSAlias(['raw string'], 
    {'python': 'r'}, no_space_after))
python_string_qualifiers.add_lsa(LSAlias(['Unicode string'], {'python': 'u' },
                                 no_space_after))

# Python-specific operators

python_operators = LSAliasSet('Python operators', 
    description = 'Python-specific operators')
python_operators.add_lsa(LSAlias(['concatenate', 'concatenate with'], 
    {'python': ' + '}, binary_operator))
python_operators.add_lsa(LSAlias(['collect arguments', 'collect positinal arguments', 
                                  'collect arguments in', 'collect positinal arguments in'], 
    {'python': '*'}, no_space_after))
python_operators.add_lsa(LSAlias(['collect keyword arguments','collect keyword arguments in'], 
    {'python': '**'}, no_space_after))
    

# functional names for Python-specific paired punctuation

python_functional = CSCmdSet('Python paired punctuation',
    description = "Python-specific paired punctuation")

acmd = CSCmd(spoken_forms=['tuple with elements', 'new tuple',
                           'tuple with items'],
             meanings={ContPy(): ActionInsert('(', ')', 
                                     spacing = like_open_paren)},
             docstring='python tuple with enumerated elements')
python_functional.add_csc(acmd)

acmd = CSCmd(spoken_forms=['range of'],
             meanings={ContPy(): ActionInsert('range(', ')', 
                                     spacing = no_space_after)},
             docstring='types range(^)')	
acmd = CSCmd(spoken_forms=['in range of'],
             meanings={ContPy(): ActionInsert(' in range(', ')', 
                                     spacing = no_space_after)},
             docstring='types range(^)')             
python_functional.add_csc(acmd)

# CSCs for calling standard python functions and methods

py_standard_function_calls = CSCmdSet('standard function calls', 
    description = \
    'CSCs for calling predefined functions and methods definitions')    

py_std_func_calls = StandardFunctionCallsHelper('python')

# py_std_func_calls.add_function_name(['A. two B. base sixty four'], 'a2b_base64')
# py_std_func_calls.add_function_name(['A. two B. H. Q. X.'], 'a2b_hqx')
# py_std_func_calls.add_function_name(['A. two B. U. U.'], 'a2b_uu')

py_std_func_calls.add_function_name(['abs', 'absolute', 'absolute value'], 
    'abs')

py_std_func_calls.add_function_name(['exponential'], 'exp')
py_std_func_calls.add_function_name(['floor'], 'floor')
py_std_func_calls.add_function_name(['ceiling'], 'ceil')

py_std_func_calls.add_function_name(['F. abs', 'F.  absolute', 
    'F. absolute value', 'float abs', 'float absolute', 
    'float absolute value'], 'fabs')

py_std_func_calls.add_function_name(['underscore abs', 'underscore absolute', 
    'underscore absolute value'], '__abs__')

py_std_func_calls.add_function_name(['abs path', 'absolute path'], 'abspath')

py_std_func_calls.add_function_name(['accept'], 'accept')
py_std_func_calls.add_function_name(['accept two D. year'], 'accept2dyear')

py_std_func_calls.add_function_name(['access'], 'access')

py_std_func_calls.add_function_name(['cos', 'cosine'], 'cos')
py_std_func_calls.add_function_name(['sine'], 'sin')
py_std_func_calls.add_function_name(['tangent', 'tan'], 'tan')

py_std_func_calls.add_function_name(['A. cos', 'arc cos', 'arc cosine'], 'acos')
py_std_func_calls.add_function_name(['A. sine', 'arc sine'], 'asin')
py_std_func_calls.add_function_name(['A. tan', 'arc tangent', 
    'arc tan'], 'atan')
py_std_func_calls.add_function_name(['A. tan 2', 'arc tangent 2', 
    'arc tan 2'], 'atan2')

py_std_func_calls.add_function_name(['square root'], 'sqrt')

py_std_func_calls.add_function_name(['hyperbolic sine', 'sine H.'],
    'sinh')
py_std_func_calls.add_function_name(['hyperbolic cosine', 'cosine H.', 
    'cos H.'], 'cosh')
py_std_func_calls.add_function_name(['hyperbolic tangent', 'tan H.'],
    'tanh')

py_std_func_calls.add_function_name(['A. tan H.', 'arc tan H.', 
    'arc tangent H.', 'hyperbolic arc tangent'], 'atanh')

py_std_func_calls.add_function_name(['log', 'logarithm'], 'log')

py_std_func_calls.add_function_name(['log 10', 'log base 10', 
    'logarithm base 10'], 'log10')

py_std_func_calls.add_function_name(['acquire'], 'acquire')

py_std_func_calls.add_function_name(['length'], 'len',
    'short')
py_std_func_calls.add_function_name(['string'], 'str',
    'short')
py_std_func_calls.add_function_name(['rep', 'representation'], 'repr',
    'short')
py_std_func_calls.add_function_name(['type'], 'type',
    'short')

# predefined symbols that cannot be matched to their pseud-symbol form
#py_explicit_symbols = ExplicitSymbolSet()
#py_explicit_symbols.ad_symbol('accept2dyear')

###############################################################################
# C/C++ specific stuff
###############################################################################

#
# Define native syntax of C/C++
#
define_language('C',
                LangDef(regexp_symbol='[a-zA-Z_][a-zA-Z0-9_]*',
                        regexps_no_symbols=['/\*[\s\S]*?\*/', '//[^\n]*\n',
                                            '"([^"]|\\")*?"',
                                            '\'([^\']|\\\')*?\'']))
# C preprocessor commands and aliases

c_preprocessor_cmds = CSCmdSet('C pre-processor', 
description = """dictating C pre-processor commands""")

acmd = CSCmd(spoken_forms=['header wrapper', 'wrap header'],
             meanings={ContC(): ActionHeaderWrapper()},
             docstring='insert code template for unique #include')
c_preprocessor_cmds.add_csc(acmd)

acmd = CSCmd(spoken_forms=['macro if def', 'if def', 'pound if def'],
             meanings={ContC(): ActionInsert('#ifdef ', '\n#endif\n')},
             docstring='insert code template for #ifdef')
c_preprocessor_cmds.add_csc(acmd)

acmd = CSCmd(spoken_forms=['macro if', 'pound if'],
             meanings={ContC(): ActionInsert('#if ', '\n#endif\n')},
             docstring='insert code template for #if')
c_preprocessor_cmds.add_csc(acmd)

acmd = CSCmd(spoken_forms=['macro if N. def', 'pound if N. def', 'macro if not defined', 'pound if not defined'],
             meanings={ContC(): ActionInsert('#ifndef ', '\n#endif\n')},
             docstring='insert code template for #ifndef')
c_preprocessor_cmds.add_csc(acmd)

c_preprocessor = LSAliasSet('C pre-processor aliases', 
description = """aliases for dictating C pre-processor commands""")

c_preprocessor.add_lsa(LSAlias(['macro define', 'pound define'], {'C': '#define '}))

c_preprocessor.add_lsa(LSAlias(['macro include', 'pound include'], {'C': '#include '}))

c_preprocessor.add_lsa(LSAlias(['macro undo define', 'undefine', 'pound undefine'], {'C': '#undef '}))



# Other C/C++ statements
c_statements = CSCmdSet('C/C++ statements', 
                        description = """dictating miscellaneous C/C++ statements""")

acmd = CSCmd(spoken_forms=['try'],
             meanings={ContC(): ActionInsert('try {\n\t', '\n}', 
                                             spacing = no_space_after)},
             docstring='insert code template for C++ try block')
c_statements.add_csc(acmd)

acmd = CSCmd(spoken_forms=['catch'],
             meanings={ContC(): ActionInsert('catch (', ') {\n\t\n}', 
                                             spacing = no_space_after)},
             docstring='insert code template for C++ catch block')
c_statements.add_csc(acmd)

acmd = CSCmd(spoken_forms=['switch'],
             meanings={ContC(): ActionInsert('switch (', ') {\n\t\n}', 
                                             spacing = no_space_after)},
             docstring='insert code template for C++ catch block')
c_statements.add_csc(acmd)

acmd = CSCmd(spoken_forms=['case'],
             meanings={ContC(): ActionCompound((ActionInsert('case ARG', ':\r', 
                                                            spacing = no_space_after),
                                               ActionSearch(regexp='ARG', direction=-1, where=1),
                                               ActionBackspace(n_times=3)))},
             docstring='insert C/C++ case label template (for within a switch block)')
c_statements.add_csc(acmd)

acmd = CSCmd(spoken_forms=['default'],
             meanings={ContC(): ActionInsert('default:\r','')}, 
             docstring='insert C/C++ default label (for within a switch block)')
c_statements.add_csc(acmd)

acmd = CSCmd(spoken_forms=['type I. D.','type I. D. of'],
             meanings={ContC(): ActionInsert('typeid(',')')},
             docstring='insert typeid() operator')
c_statements.add_csc(acmd)

acmd = CSCmd(spoken_forms=['template', 'define template', 'declare template',
                           'template definition', 'template declaration',
                           'new template'],
             meanings={ContC(): cpp_template_definition},
             docstring='template definition')
data_structures.add_csc(acmd)



# C/C++ specific syntax
c_syntax = LSAliasSet('C/C++ -specific syntax',
    description = 'aliases for syntactical stuff that is C/C++ specific')

# could give this a more meaningful name: e.g. pointer-to-member?
c_syntax.add_lsa(LSAlias(['arrow'],
    {'C': '->'}))

# verbal syntactic sugar
c_syntax.add_lsa(LSAlias(['declare'],
                         {'C': ''}))

c_syntax.add_lsa(LSAlias(['address of'],
    {'C': '&'}))

c_syntax.add_lsa(LSAlias(['dereference'],
    {'C': '*'}))

c_syntax.add_lsa(LSAlias(['pointer'],
    {'C': '* '}))

# this *could* be applied to other languages, it's just hard to imagine saying 'scope operator' instead of '.'
c_syntax.add_lsa(LSAlias(['scope','scope operator'],
    {'C': '::'}))

# this usage is C++ -specific, though the symbols are not
# would like to use 'input' and 'output' here, but those words are too common.
# Could make these a CSC with the requirement that cout/cin appears before the previous statement?
c_syntax.add_lsa(LSAlias(['output pipe', 'output from'],
    {'C': '<<'}))
c_syntax.add_lsa(LSAlias(['input pipe', 'input to'],
    {'C': '>>'}))


# type declarations

c_type_declarations = CSCmdSet('C/C++ type declarations',
    description = "commands for dictating types and their declarations in C and C++")

acmd = CSCmd(spoken_forms=['pointer to'],
             meanings={ContC(): ActionInsert('', '*')},
             docstring='insert * after cursor ("pointer to int" gives "int*"')
c_type_declarations.add_csc(acmd)

acmd = CSCmd(spoken_forms=['of type'],
             meanings={ContC(): ActionInsertNewClause(r'\w+(\s*::\s*\w*)?',
             '', '', direction= -1, where = -1, add_lines = 0)},
             docstring='position cursor before previous identifier, ready to dictate type')
c_type_declarations.add_csc(acmd)

acmd = CSCmd(spoken_forms=['returning'],
             meanings={ContC(): ActionInsertNewClause(r'\w+(\s*::\s*\w*)?(\([^\;\{\}\)]*)?',
             '', '', direction= -1, where = -1, add_lines = 0)},
             docstring='position cursor before previous function identifier (previous identifier, before any parameter list)')
c_type_declarations.add_csc(acmd)

acmd = CSCmd(spoken_forms=['declare enumerator','define enumerator','enumerator','enum'],
             meanings={ContC(): ActionCompound(
    (ActionInsert('enum ARG',' {};'),
     ActionSearch(regexp='ARG', direction=-1, where=1),
     ActionBackspace(n_times=3)))},
             docstream='insert enumerator declaration template')
c_type_declarations.add_csc(acmd)

c_type_casts = CSCmdSet('C/C++ type casts',
    description = "commands for dictating type casts in C and C++")

# just use "parens" for this, don't need a separate command?
acmd = CSCmd(spoken_forms=['cast'],
             meanings={ContC(): ActionInsert('(', ')')},
             docstring='insert parens for a C-style cast')
c_type_casts.add_csc(acmd)

acmd = CSCmd(spoken_forms=['cast to'],
             meanings={ContC(): ActionInsertNewClause(r'\w+(\s*::\s*\w*)?',
             code_bef='(', code_after=') ', direction= -1, where = -1, add_lines = 0)},
             docstring='position cursor before previous identifier, ready to dictate type to cast to')
c_type_casts.add_csc(acmd)


acmd = CSCmd(spoken_forms=['constant cast'],
             meanings={ContC(): ActionInsert('const_cast<', '>()')},
             docstring='insert template text for a C++ const cast')
c_type_casts.add_csc(acmd)

acmd = CSCmd(spoken_forms=['constant cast to'],
             meanings={ContC(): ActionCompound(
                                (ActionInsertAround('[A-Za-z0-9_]*',
                                                    '[A-Za-z0-9_]*',
                                                    code_bef='const_cast<>(',
                                                    code_after=')'),
                                 ActionSearch(regexp=r'>\(', direction=-1, where=-1)))},
             docstring='insert dynamic_cast<>( ) around current expression and move cursor so ready to dictate type to cast to')
c_type_casts.add_csc(acmd)

acmd = CSCmd(spoken_forms=['dynamic cast'],
             meanings={ContC(): ActionInsert('dynamic_cast<', '>()')},
             docstring='insert template text for a C++ dynamic cast')
c_type_casts.add_csc(acmd)

acmd = CSCmd(spoken_forms=['dynamic cast to'],
             meanings={ContC(): ActionCompound(
                                (ActionInsertAround('[A-Za-z0-9_]*',
                                                    '[A-Za-z0-9_]*',
                                                    code_bef='dynamic_cast<>(',
                                                    code_after=')'),
                                 ActionSearch(regexp=r'>\(', direction=-1, where=-1)))},
             docstring='insert dynamic_cast<>( ) around current expression and move cursor so ready to dictate type to cast to')
c_type_casts.add_csc(acmd)

acmd = CSCmd(spoken_forms=['reinterpret cast'],
             meanings={ContC(): ActionInsert('reinterpret_cast<', '>()')},
             docstring='insert template text for a C++ reinterpret cast')
c_type_casts.add_csc(acmd)

acmd = CSCmd(spoken_forms=['reinterpret cast to'],
             meanings={ContC(): ActionCompound(
                                (ActionInsertAround('[A-Za-z0-9_]*',
                                                    '[A-Za-z0-9_]*',
                                                    code_bef='reinterpret_cast<>(',
                                                    code_after=')'),
                                 ActionSearch(regexp=r'>\(', direction=-1, where=-1)))},
             docstring='insert reinterpret_cast<>( ) around current expression and move cursor so ready to dictate type to cast to')
c_type_casts.add_csc(acmd)

acmd = CSCmd(spoken_forms=['static cast'],
             meanings={ContC(): ActionInsert('static_cast<', '>()')},
             docstring='insert template text for a C++ static cast')
c_type_casts.add_csc(acmd)

acmd = CSCmd(spoken_forms=['static cast to'],
             meanings={ContC(): ActionCompound(
                                (ActionInsertAround('[A-Za-z0-9_]*',
                                                    '[A-Za-z0-9_]*',
                                                    code_bef='static_cast<>(',
                                                    code_after=')'),
                                 ActionSearch(regexp=r'>\(', direction=-1, where=-1)))},
             docstring='insert static_cast<>( ) around current expression and move cursor so ready to dictate type to cast to')
c_type_casts.add_csc(acmd)


# C/C++-specific navigation

c_navigation = CSCmdSet('C/C++ navigation', 
description = """Special navigational commands for C/C++""")

# it would be nicer if this could look backwards...

acmd = CSCmd(spoken_forms=['public member','new public member', 'public members'],
             meanings={ContC(): ActionSearch(regexp='public:\s*?($|\n)( \t)*',
                                             direction=1, where=1)},
             docstring='move to public members')
c_navigation.add_csc(acmd)

acmd = CSCmd(spoken_forms=['private member','new private member', 'private members'],
             meanings={ContC(): ActionSearch(regexp='private:',
                                             direction=1, where=1)},
             docstring='move to private members')
c_navigation.add_csc(acmd)

acmd = CSCmd(spoken_forms=['protected member','new protected member', 'protected members'],
             meanings={ContC(): ActionSearch(regexp='protected:',
                                             direction=1, where=1)},
             docstring='move to protected members')
c_navigation.add_csc(acmd)


# C/C++ reserved words

c_reserved_words = LSAliasSet('C/C++ keywords', 
    description = 'aliases for reserved words in C/C++')

c_reserved_words.add_lsa(LSAlias(['asm', 'assembly', 'A. S. M.'],
        {'C': 'asm '})) # this is compiler-dependent... :-(
c_reserved_words.add_lsa(LSAlias(['auto', 'automatic'],
        {'C': 'auto '}))
c_reserved_words.add_lsa(LSAlias(['char'],
        {'C': 'char '}))
# the 'class' keyword prevents us from using 'class' as a CSC for defining a new class!
c_reserved_words.add_lsa(LSAlias(['class'],
        {'C': 'class '}))
c_reserved_words.add_lsa(LSAlias(['constant','const'],
        {'C': 'const '}))
c_reserved_words.add_lsa(LSAlias(['delete'],
        {'C': 'delete '}))
c_reserved_words.add_lsa(LSAlias(['double'],
        {'C': 'double '}))
c_reserved_words.add_lsa(LSAlias(['explicit'],
        {'C': 'explicit '}))
c_reserved_words.add_lsa(LSAlias(['export'],
        {'C': 'export '})) # rare!
c_reserved_words.add_lsa(LSAlias(['extern', 'external'],
        {'C': 'extern '}))
c_reserved_words.add_lsa(LSAlias(['float'],
        {'C': 'float '}))
c_reserved_words.add_lsa(LSAlias(['friend'],
        {'C': 'friend '}))
c_reserved_words.add_lsa(LSAlias(['go to'],
        {'C': 'goto '}))
c_reserved_words.add_lsa(LSAlias(['inline'],
        {'C': 'inline '}))
c_reserved_words.add_lsa(LSAlias(['int','integer'],
        {'C': 'int '}))
c_reserved_words.add_lsa(LSAlias(['long'],
        {'C': 'long '}))
c_reserved_words.add_lsa(LSAlias(['mutable'],
        {'C': 'mutable '}))
c_reserved_words.add_lsa(LSAlias(['namespace'],
        {'C': 'namespace '}))
c_reserved_words.add_lsa(LSAlias(['new'],
        {'C': 'new '}))
c_reserved_words.add_lsa(LSAlias(['public'],
        {'C': 'public '}))
c_reserved_words.add_lsa(LSAlias(['private'],
        {'C': 'private '}))
c_reserved_words.add_lsa(LSAlias(['protected'],
        {'C': 'protected '}))
c_reserved_words.add_lsa(LSAlias(['register'],
        {'C': 'register '}))
c_reserved_words.add_lsa(LSAlias(['short'],
        {'C': 'short '}))
c_reserved_words.add_lsa(LSAlias(['signed'],
        {'C': 'signed '}))
c_reserved_words.add_lsa(LSAlias(['size of'],
        {'C': 'sizeof '}))
c_reserved_words.add_lsa(LSAlias(['static'],
        {'C': 'static '}))
c_reserved_words.add_lsa(LSAlias(['throw'],
        {'C': 'throw '}))
c_reserved_words.add_lsa(LSAlias(['type name'],
        {'C': 'typename '}))
c_reserved_words.add_lsa(LSAlias(['typedef'],
        {'C': 'typedef '}))
c_reserved_words.add_lsa(LSAlias(['unsigned'],
        {'C': 'unsigned '}))
c_reserved_words.add_lsa(LSAlias(['using'],
        {'C': 'using '}))
c_reserved_words.add_lsa(LSAlias(['virtual'],
        {'C': 'virtual '}))
c_reserved_words.add_lsa(LSAlias(['void'],
        {'C': 'void '}))
c_reserved_words.add_lsa(LSAlias(['volatile'],
        {'C': 'volatile '}))
c_reserved_words.add_lsa(LSAlias(['wchar_t','wide char type'],
        {'C': 'wchar_t '}))





###############################################################################
# Emacs specific stuff
###############################################################################

emacs_ctrl = CSCmdSet(name = 'emacs control',
    description = 'commands to control Emacs')
acmd = CSCmd(spoken_forms=['yo list buffers', 'yo switch to buffer', 
                           'yo switch buffer', 'yo list files', 'yo switch to file', 
                           'yo switch file'], 
             meanings={ContEmacs(): ActionEmacsListBuffers()}, 
             docstring='open the Emacs buffer list.')
emacs_ctrl.add_csc(acmd)
acmd = CSCmd(spoken_forms=['new line', 'enter', 'choose that'], 
             meanings={cont_emacs_in_selection_buff: ActionTypeText("{Enter}")}, 
             docstring='types "enter" in an Emacs selection buffer (e.g. *Buffer List*).')
emacs_ctrl.add_csc(acmd)             
acmd = CSCmd(spoken_forms=['yo save file', 'yo save buffer'], 
             meanings={ContEmacs(): ActionTypeText("{Esc}xsave-buffer{Enter}")}, 
             docstring='Save the current Emacs buffer.')
emacs_ctrl.add_csc(acmd)             
acmd = CSCmd(spoken_forms=['yo find file', 'yo open file'], 
             meanings={ContEmacs(): ActionTypeText("{Esc}xdired{Enter}")}, 
             docstring='opens an Emacs dired buffer.')
emacs_ctrl.add_csc(acmd)             

###############################################################################
# Define syntax of a pseudo-language used only to compile symbols for
# file names
###############################################################################
define_language('file_names',
                LangDef(regexp_symbol='[a-zA-Z0-9\\-_]+',
                        regexps_no_symbols=[]))



######################################################################
# Symbol formatting
######################################################################

add_identifier('class')
add_identifier('object instance')
add_identifier('function')
add_identifier('method', 'function')
add_identifier('private method', 'method')
add_identifier('operator', 'method')
add_identifier('attribute')
add_identifier('private attribute', 'attribute')

set_builder_preferences(['std_underscores', 'std_intercaps',
    'std_all_caps_underscores'])
set_builder_preferences(['std_intercaps', 'std_underscores',
    'std_all_caps_underscores'], identifier = 'class')

###############################################################################
# Add words which are missing from the SR vocab
###############################################################################

sr_interface.addWord('ellipsis')
sr_interface.addWord('paren')
sr_interface.addWord('parens')
sr_interface.addWord('tilde')
# 'un' prefix as in unspecified, untranslated etc...
sr_interface.addWord('un')


#
# For some reason, if we don't add this word, ['sub', 'class'] is often
# recognised as ['sub\\sub routine', 'class'] (even if I use recognitionMimic).
# This causes problems because the spoken form of this is 'sub routine class'
# which the interpreter doesn't understand.
#
# Wonder why NatSpeak insists on sending a word with spoken form
# 'sub routine'
#
sr_interface.addWord('sub class\\sub class')


if (__name__ == '__main__'): sr_interface.disconnect()
